# Гібридний постквантовий протокол автентифікації на основі парольного ключового обміну OPAQUE з інтеграцією ML-KEM-768

---

## АНОТАЦІЯ

Протокол OPAQUE є найбільш безпечним представником асиметричних PAKE, проте його криптографічна основа — ключовий обмін 3DH на еліптичних кривих — вразлива до квантових атак за алгоритмом Шора. Стратегія "harvest now, decrypt later" робить цю загрозу актуальною вже сьогодні.

Запропоновано конструкцію Hybrid PQ-OPAQUE, в якій ML-KEM-768 (FIPS 203) інтегровано в потік 3DH як обов'язкову складову. Класичний ключовий матеріал від трьох операцій Діффі--Геллмана на Ristretto255 (96 байт) конкатенується зі спільним секретом ML-KEM-768 (32 байт) та обробляється HKDF-Extract (HMAC-SHA-512) із контекстно-залежною сіллю, що містить хеш транскрипту, включаючи постквантовий ключ та шифротекст.

Конструкція зберігає всі властивості OPAQUE (секретність паролю, forward secrecy, взаємну автентифікацію, стійкість до офлайн-перебору) та додає стійкість до квантових атак за AND-моделлю. Формальна верифікація: ProVerif 2.05 (5/5 запитів підтверджено, включаючи секретність при компрометації LTK сервера) та Tamarin Prover (8 лем, включаючи AND-model security). Протокол зберігає 3 повідомлення та 1.5 RTT класичного OPAQUE; overhead складає +2272 байти, зумовлений виключно артефактами ML-KEM-768. Обчислювальні витрати — 5.8 мкс на гібридний комбінатор; 99.8% латентності припадає на Argon2id.

**Ключові слова:** OPAQUE, парольний автентифікований ключовий обмін (PAKE), ML-KEM-768, постквантова криптографія, гібридний ключовий обмін, Ristretto255, HKDF, механізм інкапсуляції ключів, квантова стійкість, формальна верифікація, ProVerif, Tamarin Prover.

---

## 1. ВСТУП

### 1.1. Актуальність проблеми

Парольна автентифікація залишається найбільш поширеним механізмом підтвердження особи в сучасних розподілених інформаційних системах. За різними оцінками, понад 80% процедур автентифікації у веб-додатках та мережевих сервісах базуються на паролях [1, 2]. Незважаючи на активний розвиток альтернативних підходів -- біометричної автентифікації, апаратних токенів стандарту FIDO2, автентифікації на основі сертифікатів -- паролі зберігають домінуючу позицію завдяки простоті розгортання, відсутності потреби у спеціалізованому обладнанні та звичності для кінцевих користувачів. Ця реальність визначає критичну важливість криптографічно коректних протоколів парольної автентифікації для безпеки глобальної цифрової інфраструктури.

Протоколи парольного автентифікованого ключового обміну (Password-Authenticated Key Exchange, PAKE) забезпечують встановлення захищеного каналу зв'язку між двома сторонами, які поділяють спільний секрет низької ентропії -- пароль -- без розкриття цього паролю пасивному чи активному противнику [3]. Серед існуючих протоколів PAKE протокол OPAQUE, запропонований Jarecki, Krawczyk та Xu у 2018 році [4], вважається найбільш безпечним представником класу асиметричних (augmented) PAKE. На відміну від збалансованих протоколів, де обидві сторони зберігають пароль, в асиметричному PAKE сервер зберігає лише криптографічний запис (registration record), з якого неможливо відновити пароль навіть при повній компрометації серверного сховища. OPAQUE досягає цієї властивості завдяки використанню обливіусної псевдовипадкової функції (Oblivious Pseudorandom Function, OPRF) [5], яка дозволяє серверу брати участь в обчисленні криптографічного ключа на основі паролю, не отримуючи при цьому жодної інформації про сам пароль. Протокол OPAQUE перебуває на етапі стандартизації в рамках IETF CFRG [6].

Криптографічна безпека протоколу OPAQUE, як і переважної більшості сучасних протоколів PAKE, фундаментально залежить від обчислювальної складності задачі дискретного логарифмування (Discrete Logarithm Problem, DLP) та її варіанту на еліптичних кривих (Elliptic Curve Discrete Logarithm Problem, ECDLP). Ключовий обмін 3DH (triple Diffie-Hellman), що становить основу протоколу OPAQUE, виконує три операції скалярного множення на еліптичній кривій, безпека кожної з яких безпосередньо базується на складності ECDLP. Аналогічно, протокол SRP (Secure Remote Password) [7] базується на задачі DLP у мультиплікативній групі цілих чисел, а протокол SPAKE2 [8] -- на ECDLP.

### 1.2. Квантова загроза

У 1994 році Пітер Шор запропонував квантовий алгоритм [9], здатний розв'язувати задачу факторизації цілих чисел та задачу дискретного логарифмування за поліноміальний час на квантовому комп'ютері. Алгоритм Шора безпосередньо загрожує всім криптосистемам, безпека яких базується на цих задачах: RSA, протоколу Діффі--Геллмана, криптографії на еліптичних кривих (ECDH, ECDSA) [10]. Зокрема, для зламу криптографії на еліптичних кривих з рівнем безпеки 128 біт алгоритму Шора достатньо квантового комп'ютера з приблизно 2330 логічними кубітами [11]. Хоча сучасні квантові комп'ютери ще не досягли необхідного масштабу, темпи розвитку квантових технологій та значні інвестиції з боку державних та приватних структур свідчать про те, що криптографічно релевантні квантові комп'ютери (Cryptographically Relevant Quantum Computers, CRQC) можуть з'явитися протягом найближчих 10--20 років [12].

Особливу загрозу становить стратегія "збирай зараз, дешифруй пізніше" (Harvest Now, Decrypt Later, HNDL), за якої противник перехоплює та зберігає зашифрований трафік сьогодні з метою його дешифрування на квантовому комп'ютері в майбутньому [13]. У контексті парольної автентифікації ця загроза означає, що перехоплені повідомлення протоколу ключового обміну можуть бути ретроспективно проаналізовані для відновлення сеансових ключів, а потенційно -- і самих паролів. Для систем, що обробляють довготривалі конфіденційні дані (медичні записи, фінансова інформація, державна таємниця), загроза HNDL є актуальною вже сьогодні, що обумовлює необхідність превентивного переходу до постквантово стійких криптографічних протоколів.

### 1.3. Стандартизація постквантової криптографії

Усвідомлюючи масштаб квантової загрози, Національний інститут стандартів і технологій США (NIST) у 2016 році ініціював процес стандартизації постквантових криптографічних алгоритмів [14]. Після кількох раундів оцінювання, у серпні 2024 року NIST опублікував перші стандарти постквантової криптографії: FIPS 203 (ML-KEM -- Module-Lattice-Based Key-Encapsulation Mechanism) [15] та FIPS 204 (ML-DSA -- Module-Lattice-Based Digital Signature Algorithm) [16]. Стандарт ML-KEM, що базується на алгоритмі CRYSTALS-Kyber [17], визначає три набори параметрів: ML-KEM-512 (рівень безпеки NIST 1), ML-KEM-768 (рівень безпеки NIST 3) та ML-KEM-1024 (рівень безпеки NIST 5). Безпека ML-KEM базується на обчислювальній складності задачі навчання з помилками на модульних решітках (Module Learning With Errors, Module-LWE), для якої не відомо ефективних квантових алгоритмів розв'язання [17].

Паралельно з процесом стандартизації окремих примітивів, індустрія розпочала інтеграцію постквантових механізмів у існуючі протоколи. Гібридні підходи, що комбінують класичну та постквантову криптографію, впроваджуються в TLS 1.3 [18], протокол Signal (PQXDH) [19] та WireGuard [20]. Ключовою перевагою гібридного підходу є забезпечення безпеки за моделлю "AND": для зламу системи противнику необхідно подолати одночасно обидві криптографічні складові, що дозволяє зберегти захист навіть у разі виявлення вразливості в одній з них [21].

### 1.4. Обмеження існуючих рішень

Аналіз сучасного стану постквантової парольної автентифікації виявляє значну прогалину між потребами та наявними рішеннями.

По-перше, класичний протокол OPAQUE у його поточній специфікації IETF [6] не містить жодних механізмів захисту від квантових атак. Ключовий обмін 3DH виконується виключно на еліптичних кривих, і весь ключовий матеріал, з якого виводяться сеансові ключі, може бути відновлений противником, що володіє квантовим комп'ютером, здатним розв'язувати задачу ECDLP.

По-друге, інші широко використовувані протоколи парольної автентифікації -- SRP [7] та SPAKE2 [8] -- є так само вразливими до квантових атак, оскільки їхня безпека базується відповідно на задачі DLP у мультиплікативних групах та ECDLP. Більше того, ці протоколи не забезпечують рівня безпеки OPAQUE: SRP не має формального доведення безпеки в моделі UC-security [22], а SPAKE2 є збалансованим PAKE, що не забезпечує захисту від компрометації сервера.

По-третє, чисто постквантові протоколи PAKE перебувають на ранній стадії дослідження та не досягли достатнього рівня зрілості для практичного застосування. Існуючі пропозиції PQ-PAKE здебільшого базуються на решітковій криптографії, проте стикаються з проблемами ефективності, відсутності формальних доведень безпеки та недостатньою дослідженістю у реальних умовах розгортання [23]. Відсутність класичного криптографічного "запасного варіанту" (fallback) у чисто постквантових конструкціях створює ризик повної втрати безпеки у разі виявлення вразливості в базовій постквантовій задачі -- ризик, який не є гіпотетичним, враховуючи відносну молодість решіткових криптосистем порівняно з десятиліттями криптоаналізу класичних схем.

По-четверте, існуючі гібридні рішення, впроваджені в TLS 1.3, Signal та WireGuard, вирішують проблему постквантового захисту ключового обміну, проте жодне з них не адресує специфіку парольної автентифікації: вони не використовують OPRF для приховування паролю, не забезпечують захист від компрометації серверного сховища та не реалізують модель асиметричного PAKE. У відкритій науковій літературі на момент проведення дослідження відсутні стандартизовані чи формально проаналізовані гібридні постквантові розширення протоколу OPAQUE, що становить відкриту дослідницьку проблему, на вирішення якої спрямоване дане дослідження.

### 1.5. Мета та завдання дослідження

Метою даного дослідження є розробка, реалізація та аналіз гібридної постквантової конструкції на основі протоколу OPAQUE, що забезпечує одночасну стійкість до класичних та квантових криптоаналітичних атак без втрати існуючих властивостей безпеки базового протоколу.

Для досягнення зазначеної мети поставлено такі завдання:

1) здійснити аналіз існуючих протоколів парольного автентифікованого ключового обміну та гібридних постквантових рішень з метою ідентифікації прогалин та можливостей розширення;

2) розробити конструкцію гібридного комбінатора ключового матеріалу, що інтегрує механізм інкапсуляції ключів ML-KEM-768 у потік автентифікованого ключового обміну 3DH протоколу OPAQUE;

3) визначити механізм розширеного транскрипту, що включає постквантові елементи (відкритий ключ KEM та шифротекст) для забезпечення цілісності та зв'язування всіх криптографічних контекстів;

4) провести аналіз безпеки запропонованої конструкції щодо збереження фундаментальних властивостей протоколу OPAQUE та набуття постквантової стійкості;

5) виконати формальну верифікацію протоколу у системах автоматичного доведення ProVerif та Tamarin Prover для машинно-перевірюваного підтвердження ключових властивостей безпеки;

6) реалізувати запропонований протокол у вигляді кросплатформної бібліотеки та провести систематичну оцінку продуктивності з мікробенчмарками окремих криптопримітивів, макробенчмарками фаз протоколу та вимірюванням серверної пропускної здатності.

### 1.6. Наукова новизна та внесок

Основний науковий внесок даної роботи полягає в наступному:

1. **Гібридна конструкція PQ-OPAQUE.** Вперше запропоновано та реалізовано гібридну схему розширення протоколу OPAQUE, в якій механізм інкапсуляції ключів ML-KEM-768 є обов'язковою складовою протоколу. Паттерн гібридного комбінування ключового матеріалу від DH та KEM є відомим і застосовується в TLS 1.3 hybrid [18], Signal PQXDH [19] та конструкціях KEM-комбінаторів [42]. Наукова новизна полягає у *застосуванні цього паттерна до асиметричного PAKE* — класу протоколів зі специфічними вимогами (OPRF, конверт, KSF), що потребують окремого аналізу безпеки.

2. **Адаптація комбінатора для контексту aPAKE.** Розроблено конструкцію комбінування через HKDF-Extract (HMAC-SHA-512) з контекстно-залежною сіллю, що містить мічений хеш транскрипту, включаючи постквантові елементи. На відміну від TLS 1.3 hybrid, де комбінатор працює з двома DH-секретами, тут комбінуються *три* DH-операції (96 байт) та один KEM-секрет (32 байт), причому DH-компоненти виконують різні ролі (автентифікація та forward secrecy).

3. **Розширений транскрипт з постквантовими елементами.** Запропоновано включення відкритого ключа ML-KEM (kem_public_key, 1184 байти) та шифротексту (kem_ciphertext, 1088 байт) у транскрипт протоколу, що обчислюється як вхід для MAC-автентифікації обох сторін.

4. **Збереження всіх властивостей безпеки OPAQUE.** Показано, що запропонована гібридна конструкція зберігає секретність паролю, пряму секретність (forward secrecy), взаємну автентифікацію та стійкість до офлайн-атак перебору за словником, одночасно додаючи стійкість до квантових атак за моделлю "AND".

5. **Формальна верифікація та емпірична валідація.** Виконано формальну верифікацію протоколу у системі автоматичного доведення ProVerif 2.05 — підтверджено 5 з 5 запитів безпеки (секретність сеансового ключа та паролю при компрометації серверних ключів, взаємна автентифікація обох напрямків, ін'єктивна відповідність). Побудовано символьну модель у Tamarin Prover з 8 лемами безпеки (включаючи AND-model security та класичну/постквантову forward secrecy). Проведено систематичну оцінку продуктивності з мікробенчмарками окремих криптопримітивів та макробенчмарками фаз протоколу.

### 1.7. Структура статті

Стаття організована таким чином. У розділі 2 наведено аналіз літературних джерел та існуючих рішень. Розділ 3 присвячено формальній постановці задачі. У розділі 4, що становить основну частину роботи, детально описано запропонований протокол Hybrid PQ-OPAQUE. Розділ 5 містить аналіз безпеки, включаючи формальну верифікацію у системах ProVerif та Tamarin Prover. У розділі 6 описано реалізацію та наведено результати систематичної експериментальної оцінки продуктивності. Розділ 7 містить обговорення результатів. Висновки подано у розділі 8.

---

## 2. АНАЛІЗ ЛІТЕРАТУРНИХ ДЖЕРЕЛ ТА ІСНУЮЧИХ РІШЕНЬ

### 2.1 Протоколи парольного автентифікованого ключового обміну (PAKE)

Парольний автентифікований ключовий обмін (Password-Authenticated Key Exchange, PAKE) -- клас протоколів, які дозволяють двом сторонам, що поділяють спільний секрет низької ентропії (пароль), встановити автентифікований канал зв'язку із сесійним ключем високої ентропії, стійким до офлайн-атак перебору за словником [24]. Центральна проблема, яку вирішують PAKE-протоколи, полягає в тому, що пароль є єдиним спільним секретом між сторонами, тоді як класичні протоколи ключового обміну (наприклад, Діффі--Геллмана) не забезпечують автентифікації, а протоколи, що передають пароль відкритим текстом, вразливі до перехоплення.

**Таксономія PAKE.** Протоколи PAKE поділяються на дві фундаментальні категорії за моделлю зберігання парольної інформації [25]:

- *Збалансовані (balanced) PAKE* -- обидві сторони зберігають ідентичне парольне представлення (сам пароль або його симетричну функцію). Прикладами є EKE [25], SPAKE2 [8], CPace [28]. Ці протоколи природно підходять для peer-to-peer сценаріїв, де обидві сторони є рівноправними.

- *Асиметричні (augmented) PAKE, або aPAKE* -- сервер зберігає лише парольний верифікатор, який не дозволяє проводити офлайн-атаку перебору навіть у разі повної компрометації серверної бази даних. Клієнт використовує пароль, а сервер -- верифікатор, що є однобічною функцією від пароля. Прикладами є SRP [7], AuCPace [26], OPAQUE [4]. Асиметричні протоколи є переважними для клієнт-серверних архітектур, оскільки витік серверних даних не дає противнику можливості безпосередньо виконати офлайн-атаку за словником.

**EKE (Encrypted Key Exchange).** Протокол EKE, запропонований Белловіним та Мерріттом у 1992 році [25], є першим формалізованим PAKE-протоколом. Ідея EKE полягає в тому, що обидві сторони шифрують повідомлення протоколу Діффі--Геллмана спільним паролем. Проте EKE має суттєві практичні обмеження: залежність від ідеального шифру (ideal cipher model), труднощі з вибором кодування елементів групи та патентні обмеження [3]. Крім того, EKE є збалансованим протоколом, що робить його непридатним для моделі, де компрометація серверу не повинна давати інформацію про пароль.

**SRP (Secure Remote Password).** Протокол SRP, розроблений Ву у Стенфордському університеті [7] та стандартизований в RFC 2945, є найбільш поширеним aPAKE у практичних застосуваннях. SRP використовується в Apple iCloud, 1Password та інших системах. Сервер зберігає верифікатор $v = g^x$, де $x = H(\text{salt}, \text{password})$, і не може відновити пароль із верифікатора без розв'язання задачі дискретного логарифма. Проте SRP не має формального доведення безпеки в жодній визнаній моделі, а верифікатор є детермінованою функцією пароля, що дозволяє проводити попередні обчислення (pre-computation attacks) [4].

**SPAKE2.** Протокол SPAKE2, запропонований Абдаллою та Пуантшевалем [8], є збалансованим PAKE з елегантною конструкцією: сторони маскують елементи Діффі--Геллмана за допомогою фіксованих генераторів групи $M$ та $N$, помножених на хеш пароля. SPAKE2 має формальне доведення безпеки в моделі випадкового оракула (Random Oracle Model) та стандартизований IETF у RFC 9382 [27]. Однак SPAKE2 є збалансованим протоколом, що обмежує його застосовність у клієнт-серверних сценаріях.

**OPAQUE.** Протокол OPAQUE (Oblivious Pseudo-Random Function Augmented Password-Authenticated Key Exchange), запропонований Ярецьким, Кравчиком та Сюй у 2018 році [4], є найбільш безпечним відомим aPAKE-протоколом. Ключова інновація OPAQUE полягає в використанні забутливої псевдовипадкової функції (OPRF) для маскування парольного матеріалу таким чином, що сервер ніколи не отримує навіть хешу пароля. OPAQUE має формальне доведення безпеки в моделі універсальної композиції (UC-framework) Канетті [22], що є найсильнішою з відомих моделей безпеки для PAKE-протоколів.

*Таблиця 1 -- Порівняльна характеристика протоколів PAKE*

| Властивість | EKE [25] | SRP [7] | SPAKE2 [8] | OPAQUE [4] |
|---|---|---|---|---|
| Тип (balanced/augmented) | Balanced | Augmented | Balanced | Augmented |
| Приховування пароля від сервера | Ні | Частково | Ні | Так (OPRF) |
| Стійкість до pre-computation | Ні | Ні | Ні | Так |
| Forward secrecy | Так | Так | Так | Так |
| Стійкість до компрометації сервера | Ні | Часткова | Ні | Так |
| Формальне доведення безпеки | IC model | Відсутнє | ROM | UC model |
| Стійкість до квантових атак | Ні | Ні | Ні | Ні |

### 2.2 Протокол OPAQUE: формальний опис

Протокол OPAQUE [4] складається з двох основних фаз: реєстрації та автентифікації. Обидві фази спираються на механізм забутливої псевдовипадкової функції (OPRF) як ключовий будівельний блок.

**Забутлива псевдовипадкова функція (OPRF).** OPRF -- це двосторонній протокол між клієнтом та сервером, у якому сервер обчислює псевдовипадкову функцію $F_k(x)$ на вході клієнта $x$ за допомогою свого секретного ключа $k$, при цьому сервер не дізнається вхідне значення $x$, а клієнт не дізнається ключ $k$ [5]. Формально, OPRF має дві ключові властивості:

- *Засліплення (blindness)*: сервер не отримує жодної інформації про вхід $x$ клієнта. Клієнт засліплює свій вхід випадковим скаляром $r$, надсилаючи $\alpha = H'(x)^r$ серверу, який обчислює $\beta = \alpha^k$ і повертає результат. Клієнт відновлює $F_k(x) = \beta^{r^{-1}} = H'(x)^k$.

- *Псевдовипадковість*: вихід $F_k(x)$ є обчислювально невідрізнимим від випадкового елемента, навіть для зловмисника, що обирає вхід $x$ адаптивно, за умови, що ключ $k$ невідомий.

В реалізації OPAQUE з групою Ristretto255 [29] засліплення виконується через скалярне множення на еліптичній кривій Curve25519, що забезпечує ефективність і безпеку на рівні 128 біт.

**Фаза реєстрації.** Реєстрація в OPAQUE виконується в три кроки:

1. *Blind*: клієнт обчислює засліплений елемент $\alpha = H'(\text{pwd})^r$, де $r \leftarrow \mathbb{Z}_q^*$ -- випадковий скаляр, і надсилає $\alpha$ серверу як `RegistrationRequest`.

2. *Evaluate*: сервер деривує OPRF-ключ з власного насіннєвого значення та ідентифікатора облікового запису: $k = \text{DeriveKey}(\text{seed}, \text{id})$, обчислює $\beta = \alpha^k$ і повертає $(\beta, pk_S)$ як `RegistrationResponse`.

3. *Finalize та Seal*: клієнт обчислює $F_k(\text{pwd}) = \beta^{r^{-1}}$, генерує рандомізований пароль: $rwd = \text{Argon2id}(H(\text{context} \| F_k(\text{pwd}) \| \text{pwd}), \text{salt})$ [30]. Конверт (envelope) шифрується алгоритмом XSalsa20-Poly1305 [35] і містить: $pk_S$, $sk_C$, $pk_C$. Результат -- `RegistrationRecord = (envelope, pk_C)` -- зберігається на сервері.

**Фаза автентифікації.** Автентифікація в OPAQUE виконується за допомогою тристороннього протоколу Діффі--Геллмана (3DH) [4, 32]:

- *KE1*: клієнт генерує OPRF-засліплення, ефемерну пару ключів $(e_C, E_C)$ та нонс, і надсилає $\text{KE1} = (\alpha, E_C, \text{nonce}_C)$.

- *KE2*: сервер обчислює три значення DH: $dh_1 = pk_C^{s_S}$ (статичний $\times$ статичний), $dh_2 = E_C^{s_S}$ (статичний $\times$ ефемерний), $dh_3 = pk_C^{e_S}$ (ефемерний $\times$ статичний), деривує ключі через HKDF [33], обчислює MAC і формує $\text{KE2} = (\text{nonce}_S, E_S, \text{cred\_response}, mac_S)$.

- *KE3*: клієнт розшифровує конверт, дзеркально обчислює 3DH та деривує ключі, перевіряє $mac_S$, надсилає $\text{KE3} = mac_C$.

**Властивості безпеки в моделі UC.** В рамках UC-моделі [22] доведені: секретність паролю, forward secrecy, взаємна автентифікація та стійкість до попередніх обчислень. Стандартизований варіант OPAQUE (IETF draft [6]) не включає постквантових компонентів.

### 2.3 Постквантова криптографія та механізми інкапсуляції ключів

**Квантова загроза.** Алгоритм Шора [9] здатний розв'язати DLP та ECDLP за поліноміальний час на квантовому комп'ютері, що робить небезпечними RSA, ECDH та всі PAKE-протоколи, що на них базуються. Стратегія HNDL [13] робить загрозу актуальною вже сьогодні.

**Стандартизація NIST PQC.** У серпні 2024 року NIST опублікував стандарти: FIPS 203 (ML-KEM) [15], FIPS 204 (ML-DSA) [16] та FIPS 205 (SLH-DSA). ML-KEM базується на стійкості задачі навчання з помилками над модульними решітками (Module-LWE) [34].

**ML-KEM-768.** Для цілей цього дослідження обрано ML-KEM-768, що забезпечує рівень безпеки NIST Level 3 (еквівалентний AES-192). Параметри:

- Розмір відкритого ключа: $|pk| = 1184$ байт
- Розмір шифротексту: $|ct| = 1088$ байт
- Розмір спільного секрету: $|ss| = 32$ байт
- Розмір секретного ключа: $|sk| = 2400$ байт
- Рівень безпеки: IND-CCA2

Механізм складається з трьох алгоритмів: $\text{KeyGen}() \to (pk, sk)$, $\text{Encaps}(pk) \to (ct, ss)$, $\text{Decaps}(sk, ct) \to ss$ [15].

**Існуючі гібридні підходи.** Гібридний ключовий обмін, що комбінує класичні та постквантові примітиви, впроваджується в:

- *TLS 1.3 Hybrid* [18]: ML-KEM-768 + X25519 у рукостисканні. Не є PAKE -- покладається на сертифікати X.509.
- *Signal PQXDH* [19]: розширює X3DH додатковим ML-KEM-768 ключем. Не є PAKE.
- *WireGuard PQ* [20]: додає раунд Kyber до Noise IK. Не є парольним протоколом.

**Відкрита проблема.** Жоден із стандартизованих або впроваджених гібридних постквантових протоколів не забезпечує парольного автентифікованого ключового обміну. Для OPAQUE не існує стандартизованого постквантового розширення. Специфікація IETF [6] визначає інстанціювання виключно з класичними примітивами. Окремі теоретичні роботи досліджують PQ-PAKE [23], однак пропонують нові протоколи "з нуля", а не гібридні розширення існуючих перевірених конструкцій. Підхід гібридного розширення OPAQUE залишається нерозробленим, що визначає наукову новизну даного дослідження.

---

## 3. ПОСТАНОВКА ЗАДАЧІ

### 3.1 Формулювання проблеми та модель загроз

Нехай $\mathcal{C}$ (клієнт/ініціатор) та $\mathcal{S}$ (сервер/респондер) -- дві сторони протоколу, де $\mathcal{C}$ володіє паролем $\text{pwd}$, а $\mathcal{S}$ зберігає реєстраційний запис $\text{rec}$, отриманий на фазі реєстрації. Позначимо через $\mathbb{G}$ групу Ristretto255 простого порядку $q$ з генератором $g$.

**Активи, що підлягають захисту:**
- Пароль користувача $\text{pwd}$
- Статичні приватні ключі сторін: $sk_C$, $sk_S$
- Ефемерні приватні ключі: $e_C$, $e_S$, $sk_{\text{kem}}$
- Реєстраційний запис: $\text{rec} = (\text{envelope}, pk_C)$
- Сеансовий ключ $K_s$ та майстер-ключ $K_m$
- Спільний секрет ML-KEM: $ss_{\text{kem}}$

**Модель противника.** Розглядаємо три класи противників:

*Класичний противник* $\mathcal{A}_C$ -- обчислювально обмежений противник (поліноміальний час), здатний: перехоплювати та модифікувати повідомлення в мережі (активний MITM); ініціювати довільну кількість паралельних сесій; компрометувати серверне сховище (отримати $\text{rec}$); виконувати офлайн-атаки перебору за словником.

*Квантовий противник* $\mathcal{A}_Q$ -- противник з доступом до квантового комп'ютера, здатний: розв'язувати задачу DLP та ECDLP за поліноміальний час (алгоритм Шора); реалізовувати стратегію HNDL -- зберігати перехоплений трафік для подальшого криптоаналізу.

*Композитний противник* $\mathcal{A}_{CQ}$ -- противник, що поєднує можливості $\mathcal{A}_C$ та $\mathcal{A}_Q$: активний MITM + квантовий оракул для DLP/ECDLP.

**Межі довіри:**
- Пристрій клієнта ($\mathcal{C}$) є недовіреним для сервера
- Мережевий канал є недовіреним (відкритий для перехоплення та модифікації)
- Сервер зберігає реєстраційні записи та ідентифікатори облікових записів
- Криптографічні бібліотеки (libsodium, liboqs) вважаються довіреними

**Вимоги до розв'язку.** Необхідно розробити протокол $\Pi$, що задовольняє такі вимоги:

- **R1 (Збереження властивостей OPAQUE):** $\Pi$ повинен зберігати секретність паролю, пряму секретність, взаємну автентифікацію та стійкість до офлайн-атак перебору за словником.

- **R2 (Постквантова стійкість):** Ключовий обмін у $\Pi$ повинен бути стійким до атак квантового противника $\mathcal{A}_Q$, зокрема до стратегії HNDL.

- **R3 (Мінімальний overhead):** Додаткові витрати $\Pi$ порівняно з класичним OPAQUE повинні бути мінімальними за обсягом повідомлень та обчислювальною складністю.

- **R4 (Гібридна безпека, модель "AND"):** Для зламу ключового обміну в $\Pi$ противник повинен подолати одночасно і класичну (ECDLP), і постквантову (Module-LWE) складові. Формально: якщо хоча б одна задача є обчислювально складною, сеансовий ключ залишається псевдовипадковим.

- **R5 (Сумісність з інфраструктурою):** $\Pi$ повинен зберігати кількість повідомлень (3) та кількість раундів (1,5 RTT) класичного OPAQUE.

### 3.2 Формальні визначення

**Визначення 1 (Механізм інкапсуляції ключів, KEM).** KEM -- це трійка алгоритмів $(\text{KeyGen}, \text{Encaps}, \text{Decaps})$:
- $\text{KeyGen}() \to (pk, sk)$ -- генерація ключової пари;
- $\text{Encaps}(pk) \to (ct, ss)$ -- інкапсуляція спільного секрету;
- $\text{Decaps}(sk, ct) \to ss$ -- декапсуляція спільного секрету.

KEM є IND-CCA2 безпечним, якщо жоден поліноміально обмежений противник з доступом до оракула декапсуляції не може відрізнити реальний $ss$ від випадкового з неперенебрежною перевагою.

**Визначення 2 (Гібридний aPAKE).** Гібридний асиметричний PAKE -- це протокол $\Pi$ між $\mathcal{C}(\text{pwd})$ та $\mathcal{S}(\text{rec})$, в якому:
- Ключовий матеріал формується з двох незалежних джерел: класичного (ECDLP-based) та постквантового (lattice-based KEM);
- Безпека ключового обміну гарантується за умови обчислювальної складності хоча б однієї з базових задач;
- Зберігаються всі властивості базового aPAKE.

**Визначення 3 (PRF-безпека HKDF).** Функція $\text{HKDF-Extract}(\text{salt}, \text{IKM})$ на основі HMAC-SHA-512 є $\varepsilon$-PRF: для довільного $\text{salt}$ фіксованої довжини та випадкового $\text{IKM}$, вихід $\text{PRK}$ є обчислювально невідрізнимим від рівномірно випадкового рядка тієї ж довжини з перевагою не більше $\varepsilon$.

**Нотація.** У подальшому викладі використовується така нотація:
- $\mathbb{G}$ -- група Ristretto255, $|\mathbb{G}| = q$ (простий порядок, ~252 біт)
- $g$ -- генератор $\mathbb{G}$
- Малі літери ($a, b, r, e$) -- скаляри з $\mathbb{Z}_q$
- Великі літери ($A, B, E$) -- елементи групи $\mathbb{G}$ (точки кривої)
- $a \cdot G$ або $G^a$ -- скалярне множення (обчислення точки)
- $\|$ -- конкатенація байтових рядків
- $H(\cdot)$ -- SHA-512
- $\text{HMAC}(\cdot, \cdot)$ -- HMAC-SHA-512
- $\mathcal{K} = (K_s, K_m)$ -- пара (сеансовий ключ, майстер-ключ)

---

## 4. ЗАПРОПОНОВАНИЙ ПРОТОКОЛ: HYBRID PQ-OPAQUE

### 4.1 Архітектура та огляд

Запропонований протокол Hybrid PQ-OPAQUE реалізований у бібліотеці ECLIPTIX-OPAQUE та являє собою гібридну постквантову модифікацію протоколу OPAQUE [6], яка поєднує класичний обмін ключами на еліптичних кривих з механізмом інкапсуляції ключів (KEM) на основі структурованих решіток. Протокол зберігає фундаментальну властивість aPAKE --- сервер жодного разу не отримує доступу до відкритого тексту паролю клієнта --- і водночас забезпечує стійкість до атак із використанням квантових комп'ютерів у моделі "harvest now, decrypt later" [13].

Архітектурно протокол складається з двох фаз: *фази реєстрації* (Registration Phase) та *фази автентифікації* (Authentication Phase). Фаза реєстрації є одноразовою операцією, під час якої клієнт (Initiator, далі --- $\mathcal{C}$) реєструє свої облікові дані на сервері (Responder, далі --- $\mathcal{S}$) через забезпечений конвертом (envelope) механізм. Фаза автентифікації реалізує тристоронній обмін повідомленнями KE1--KE2--KE3 із додатковим кроком Server Finish, під час якого виводяться спільні сеансові ключі.

**Діаграма потоку повідомлень (Message Sequence Chart).** На Рис. 1 наведено послідовність обміну повідомленнями для фази автентифікації Hybrid PQ-OPAQUE.

```
  Клієнт (C)                                         Сервер (S)
  ══════════                                         ══════════
  Генерує:
    e_C ←$ Z_q*, E_C = e_C·g
    (pk_kem, sk_kem) ← ML-KEM.KeyGen()
    n_C ←$ {0,1}^192
    B = r · H'(pwd)                        KE1 (1272 байт)
  ─────────────────────────────────────────────────────────►
     B ‖ E_C ‖ n_C ‖ pk_kem               Валідує KE1
                                           Генерує:
                                             e_S ←$ Z_q*, E_S = e_S·g
                                             n_S ←$ {0,1}^192
                                           OPRF: Z = k_oprf · B
                                           3-DH: dh1, dh2, dh3
                                           KEM: (ct_kem, ss_kem) ← Encaps(pk_kem)
                                           combined_ikm = dh1‖dh2‖dh3‖ss_kem
                                           PRK = HKDF-Extract(salt, combined_ikm)
                                           Деривує: session_key, mac_keys
                          KE2 (1376 байт)  Обчислює responder_mac
  ◄─────────────────────────────────────────────────────────
     n_S ‖ E_S ‖ CredResp ‖ mac_S ‖ ct_kem
  OPRF finalize: rwd = Argon2id(...)
  Розкриває конверт → (PK_S, sk_C)
  Дзеркальний 3-DH: dh1, dh2, dh3
  KEM: ss_kem ← Decaps(sk_kem, ct_kem)
  PRK = HKDF-Extract(salt, combined_ikm)
  Верифікує mac_S (crypto_verify_64)
  Обчислює initiator_mac            KE3 (64 байт)
  ─────────────────────────────────────────────────────────►
     mac_C                                 Верифікує mac_C
                                           (crypto_verify_64)
                                           ──────────────────
  ═══════════════════════════════════════════════════════════
          Спільні: session_key (64 байт), master_key (32 байт)
```

*Рис. 1 --- Діаграма потоку повідомлень фази автентифікації Hybrid PQ-OPAQUE (1.5 RTT, 3 повідомлення)*

**Криптографічні примітиви.** У Таблиці 2 наведено повний перелік криптографічних примітивів, що використовуються у реалізації.

*Таблиця 2 --- Криптографічні примітиви протоколу Hybrid PQ-OPAQUE*

| Компонент | Примітив | Бібліотека | Рівень безпеки |
|---|---|---|---|
| Група OPRF | Ristretto255 / Curve25519 | libsodium | 128-біт класичний |
| Геш-функція | SHA-512 | libsodium | 256-біт |
| KDF (Extract) | HKDF-Extract (HMAC-SHA-512) | libsodium | 256-біт |
| KDF (Expand) | HKDF-Expand (HMAC-SHA-512) | libsodium | 256-біт |
| MAC | HMAC-SHA-512 | libsodium | 256-біт |
| KSF (розтягування пароля) | Argon2id | libsodium | адаптивний |
| Симетричне шифрування | XSalsa20-Poly1305 (secretbox) | libsodium | 256-біт |
| PQ-KEM | ML-KEM-768 (FIPS 203) | liboqs | NIST Level 3 |
| Обмін ключами | 3-DH на Ristretto255 | libsodium | 128-біт класичний |

Нехай $\mathbb{G}$ --- група Ristretto255, $g$ --- її базова точка, $q$ --- порядок групи. Скаляри (приватні ключі) позначаємо малими латинськими літерами ($sk, e, r$), а точки групи (відкриті ключі) --- великими ($PK, E$). Множення скаляра на точку позначаємо як $sk \cdot PK$, а множення скаляра на базову точку --- як $sk \cdot g$.

**Константи протоколу.** У Таблиці 3 наведено розміри усіх криптографічних параметрів, визначених у заголовному файлі та верифікованих статичними перевірками `static_assert` на етапі компіляції.

*Таблиця 3 --- Константи протоколу (у байтах)*

| Параметр | Позначення | Розмір |
|---|---|---|
| Приватний ключ Ristretto255 | PRIVATE_KEY_LENGTH | 32 |
| Відкритий ключ Ristretto255 | PUBLIC_KEY_LENGTH | 32 |
| Зерно OPRF | OPRF_SEED_LENGTH | 32 |
| Nonce | NONCE_LENGTH | 24 |
| MAC (HMAC-SHA-512) | MAC_LENGTH | 64 |
| Геш (SHA-512) | HASH_LENGTH | 64 |
| Конверт (envelope) | ENVELOPE_LENGTH | 136 |
| Запит на реєстрацію | REGISTRATION_REQUEST_LENGTH | 32 |
| Відповідь на реєстрацію | REGISTRATION_RESPONSE_LENGTH | 64 |
| Відповідь на облікові дані | CREDENTIAL_RESPONSE_LENGTH | 168 |
| Запис реєстрації | REGISTRATION_RECORD_LENGTH | 168 |
| Відкритий ключ ML-KEM-768 | KEM_PUBLIC_KEY_LENGTH | 1184 |
| Секретний ключ ML-KEM-768 | KEM_SECRET_KEY_LENGTH | 2400 |
| Шифротекст ML-KEM-768 | KEM_CIPHERTEXT_LENGTH | 1088 |
| Спільний секрет ML-KEM-768 | KEM_SHARED_SECRET_LENGTH | 32 |
| Комбінований IKM | COMBINED_IKM_LENGTH | 128 |
| Головний ключ | MASTER_KEY_LENGTH | 32 |

**Розміри повідомлень протоколу.** У Таблиці 4 наведено розміри повідомлень фази автентифікації.

*Таблиця 4 --- Розміри повідомлень фази автентифікації*

| Повідомлення | Формула | Розмір (байти) |
|---|---|---|
| KE1 (базовий) | REGISTRATION_REQUEST + PUBLIC_KEY + NONCE | 88 |
| KE1 (гібридний) | KE1_BASE + KEM_PUBLIC_KEY | 1272 |
| KE2 (базовий) | NONCE + PUBLIC_KEY + CREDENTIAL_RESPONSE + MAC | 288 |
| KE2 (гібридний) | KE2_BASE + KEM_CIPHERTEXT | 1376 |
| KE3 | MAC_LENGTH | 64 |

### 4.2 Фаза реєстрації

Фаза реєстрації виконується один раз і складається з трьох кроків: (1) створення запиту на реєстрацію ініціатором, (2) обробка запиту респондером, (3) фіналізація реєстрації ініціатором.

**Крок 1: Створення запиту на реєстрацію ($\mathcal{C} \to \mathcal{S}$).**

Ініціатор $\mathcal{C}$ виконує:

1. Генерація статичної ключової пари на Ristretto255:
$$sk_C \xleftarrow{\$} \mathbb{Z}_q^* \setminus \{0\}, \quad PK_C = sk_C \cdot g$$

2. OPRF-засліплення (blinding) паролю $\mathtt{pwd}$:
$$r \xleftarrow{\$} \mathbb{Z}_q^* \setminus \{0\}, \quad H = \text{HashToGroup}(\texttt{"ECLIPTIX-OPAQUE-v1/OPRF"} \| 0\text{x}00 \| \mathtt{pwd}), \quad B = r \cdot H$$

3. Формування запиту:
$$\mathtt{RegistrationRequest} = B \quad (32 \text{ байти})$$

**Крок 2: Обробка запиту ($\mathcal{S} \to \mathcal{C}$).**

Респондер $\mathcal{S}$, маючи статичний ключ $sk_S$ та ідентифікатор $\mathtt{account\_id}$, виконує:

1. Виведення OPRF-ключа:
$$\mathtt{oprf\_seed} = \text{HMAC-SHA-512}(sk_S, \texttt{"ECLIPTIX-OPAQUE-v1/OPRF-Seed"})[0{:}32]$$
$$k_{\text{oprf}} = \text{ScalarReduce}(\text{HMAC-SHA-512}(\mathtt{oprf\_seed}, \texttt{"ECLIPTIX-OPAQUE-v1/OPRF-Key"} \| \mathtt{account\_id} \| c))$$
де $c$ --- мінімальне значення лічильника, при якому $k_{\text{oprf}} \neq 0$.

2. Обчислення OPRF: $Z = k_{\text{oprf}} \cdot B$

3. Відповідь:
$$\mathtt{RegistrationResponse} = Z \| PK_S \quad (64 \text{ байти})$$

**Крок 3: Фіналізація ($\mathcal{C}$).**

1. OPRF-розсліплення: $U = r^{-1} \cdot Z = k_{\text{oprf}} \cdot H(\mathtt{pwd})$

2. Рандомізований пароль через Argon2id [30]:
$$\mathtt{rwd} = \text{Argon2id}(\text{SHA-512}(\texttt{"KSF"} \| \mathtt{oprf\_output} \| \mathtt{pwd}), \text{salt}, \text{MODERATE})$$

3. Запечатування конверта (XSalsa20-Poly1305):
$$\mathtt{envelope\_key} = \text{HKDF}(\mathtt{rwd}, \texttt{"ECLIPTIX-OPAQUE-v1/EnvelopeKey"})$$
$$\mathtt{Envelope} = n_{\text{env}} \| \text{Encrypt}(\mathtt{envelope\_key}, n_{\text{env}}, PK_S \| sk_C \| PK_C) \quad (136 \text{ байтів})$$

4. Реєстраційний запис:
$$\mathtt{RegistrationRecord} = \mathtt{Envelope} \| PK_C \quad (168 \text{ байтів})$$

### 4.3 Фаза автентифікації: гібридний ключовий обмін

Фаза автентифікації реалізує гібридний обмін ключами і складається з чотирьох кроків.

#### 4.3.1 Генерація KE1 ($\mathcal{C} \to \mathcal{S}$)

Ініціатор виконує:

1. Генерація ефемерної пари Ristretto255: $e_C \xleftarrow{\$} \mathbb{Z}_q^*, \quad E_C = e_C \cdot g$

2. Генерація ефемерної пари ML-KEM-768: $(pk_{\text{kem}}, sk_{\text{kem}}) \leftarrow \text{ML-KEM-768.KeyGen}()$

3. Генерація нонсу: $n_C \xleftarrow{\$} \{0,1\}^{192}$

4. OPRF-засліплення: $B = r \cdot \text{HashToGroup}(\mathtt{pwd})$

5. Формування:
$$\text{KE1} = B \| E_C \| n_C \| pk_{\text{kem}} \quad (32 + 32 + 24 + 1184 = 1272 \text{ байти})$$

#### 4.3.2 Генерація KE2 ($\mathcal{S} \to \mathcal{C}$)

Респондер виконує розгорнуту процедуру.

**Валідація.** Перевіряється $|$KE1$| = 1272$; $B$ верифікується як коректна ненульова точка Ristretto255; $E_C$ валідується як відкритий ключ; $PK_C$ з реєстраційного запису валідується.

**Генерація ефемерних параметрів:**
$$e_S \xleftarrow{\$} \mathbb{Z}_q^*, \quad E_S = e_S \cdot g, \quad n_S \xleftarrow{\$} \{0,1\}^{192}$$

**OPRF Evaluate:** $Z = k_{\text{oprf}} \cdot B$

**Credential Response:** $\mathtt{CredResp} = Z \| \mathtt{Envelope} \quad (168 \text{ байтів})$

**Тристоронній Діффі-Геллман (3-DH):**
$$dh_1 = sk_S \cdot PK_C \quad (\text{статичний} \times \text{статичний})$$
$$dh_2 = sk_S \cdot E_C \quad (\text{статичний} \times \text{ефемерний})$$
$$dh_3 = e_S \cdot PK_C \quad (\text{ефемерний} \times \text{статичний})$$

Кожне $dh_i$ --- 32-байтна точка $\mathbb{G}$. Комбінація забезпечує: $dh_1$ --- взаємну автентифікацію, $dh_2$ та $dh_3$ --- пряму секретність.

**Інкапсуляція ML-KEM-768:**
$$(ct_{\text{kem}}, ss_{\text{kem}}) \leftarrow \text{ML-KEM-768.Encaps}(pk_{\text{kem}})$$

**Побудова транскрипту:**
$$\mathtt{mac\_input} = E_C \| E_S \| n_C \| n_S \| PK_C \| PK_S \| \mathtt{CredResp} \| pk_{\text{kem}} \| ct_{\text{kem}}$$
$$\mathtt{transcript\_hash} = \text{SHA-512}(\texttt{"ECLIPTIX-OPAQUE-v1/Transcript"} \| \mathtt{mac\_input})$$

Включення $pk_{\text{kem}}$ та $ct_{\text{kem}}$ у транскрипт є критичним --- це зв'язує постквантовий компонент з класичним і запобігає downgrade-атакам.

**Гібридне комбінування ключового матеріалу (НАУКОВА НОВИЗНА):**

$$\mathtt{combined\_ikm} = dh_1 \| dh_2 \| dh_3 \| ss_{\text{kem}} \quad (96 + 32 = 128 \text{ байтів})$$
$$\mathtt{salt} = \texttt{"ECLIPTIX-OPAQUE-PQ-v1/Combiner"} \| \mathtt{transcript\_hash}$$
$$\mathtt{PRK} = \text{HKDF-Extract}(\mathtt{salt}, \mathtt{combined\_ikm})$$

HKDF-Extract реалізовано як $\text{HMAC-SHA-512}(\mathtt{salt}, \mathtt{combined\_ikm})$. PRK (64 байти) містить ентропію як класичного 3-DH, так і постквантового KEM. Навіть при компрометації одного з компонентів безпека PRK зберігається за рахунок другого.

**Виведення ключів:**
$$\mathtt{session\_key} = \text{HKDF-Expand}(\mathtt{PRK}, \texttt{"ECLIPTIX-OPAQUE-PQ-v1/SessionKey"}, 64)$$
$$\mathtt{master\_key} = \text{HKDF-Expand}(\mathtt{PRK}, \texttt{"ECLIPTIX-OPAQUE-PQ-v1/MasterKey"}, 32)$$
$$\mathtt{resp\_mac\_key} = \text{HKDF-Expand}(\mathtt{PRK}, \texttt{"ECLIPTIX-OPAQUE-PQ-v1/ResponderMAC"}, 64)$$
$$\mathtt{init\_mac\_key} = \text{HKDF-Expand}(\mathtt{PRK}, \texttt{"ECLIPTIX-OPAQUE-PQ-v1/InitiatorMAC"}, 64)$$

**Обчислення MAC та формування KE2:**
$$\mathtt{responder\_mac} = \text{HMAC-SHA-512}(\mathtt{resp\_mac\_key}, \mathtt{mac\_input})$$
$$\text{KE2} = n_S \| E_S \| \mathtt{CredResp} \| \mathtt{responder\_mac} \| ct_{\text{kem}} \quad (1376 \text{ байтів})$$

#### 4.3.3 Генерація KE3 ($\mathcal{C} \to \mathcal{S}$)

Ініціатор виконує:

1. **OPRF-фіналізація та відкриття конверта:** $U = r^{-1} \cdot Z$, обчислення $\mathtt{rwd}$ через Argon2id, дешифрування конверта, відновлення $(PK_S, sk_C, PK_C)$, перевірка $PK_S$ через `crypto_verify_32`.

2. **Дзеркальний 3-DH:**
$$dh_1 = sk_C \cdot PK_S, \quad dh_2 = e_C \cdot PK_S, \quad dh_3 = sk_C \cdot E_S$$
Коректність: $sk_S \cdot PK_C = sk_C \cdot PK_S$ (комутативність скалярного множення в $\mathbb{G}$).

3. **Декапсуляція ML-KEM-768:** $ss_{\text{kem}} = \text{ML-KEM-768.Decaps}(sk_{\text{kem}}, ct_{\text{kem}})$. Секретний ключ $sk_{\text{kem}}$ негайно знищується.

4. **Виведення ключів** (ідентична процедура, той самий PRK).

5. **Верифікація MAC респондера** через `crypto_verify_64` (постійний час).

6. **Формування KE3:**
$$\text{KE3} = \text{HMAC-SHA-512}(\mathtt{init\_mac\_key}, \mathtt{mac\_input}) \quad (64 \text{ байти})$$

#### 4.3.4 Завершення сесії (Server Finish)

Респондер верифікує $\mathtt{initiator\_mac}$ через `crypto_verify_64`. При успіху --- експорт $(\mathtt{session\_key}, \mathtt{master\_key})$. При невдачі --- знищення всіх ключових матеріалів через `sodium_memzero`.

Після завершення обидві сторони мають ідентичний $\mathtt{session\_key}$ (64 байти) та $\mathtt{master\_key}$ (32 байти).

### 4.4 Система доменних розділювачів

Реалізація визначає 18 унікальних рядкових констант, розділених на дві категорії.

**Класичні доменні розділювачі (12 міток):**

| Мітка | Значення |
|---|---|
| kOprfContext | `ECLIPTIX-OPAQUE-v1/OPRF` |
| kOprfKeyInfo | `ECLIPTIX-OPAQUE-v1/OPRF-Key` |
| kOprfSeedInfo | `ECLIPTIX-OPAQUE-v1/OPRF-Seed` |
| kEnvelopeContext | `ECLIPTIX-OPAQUE-v1/EnvelopeKey` |
| kHkdfSalt | `ECLIPTIX-OPAQUE-v1/HKDF-Salt` |
| kTranscriptContext | `ECLIPTIX-OPAQUE-v1/Transcript` |
| kKsfContext | `ECLIPTIX-OPAQUE-v1/KSF` |
| kKsfSaltLabel | `ECLIPTIX-OPAQUE-v1/KSF-Salt` |
| kSessionKeyInfo | `ECLIPTIX-OPAQUE-v1/SessionKey` |
| kMasterKeyInfo | `ECLIPTIX-OPAQUE-v1/MasterKey` |
| kResponderMacInfo | `ECLIPTIX-OPAQUE-v1/ResponderMAC` |
| kInitiatorMacInfo | `ECLIPTIX-OPAQUE-v1/InitiatorMAC` |

**Постквантові доменні розділювачі (6 міток):**

| Мітка | Значення |
|---|---|
| kPqCombinerContext | `ECLIPTIX-OPAQUE-PQ-v1/Combiner` |
| kPqKemContext | `ECLIPTIX-OPAQUE-PQ-v1/KEM` |
| kPqSessionKeyInfo | `ECLIPTIX-OPAQUE-PQ-v1/SessionKey` |
| kPqMasterKeyInfo | `ECLIPTIX-OPAQUE-PQ-v1/MasterKey` |
| kPqResponderMacInfo | `ECLIPTIX-OPAQUE-PQ-v1/ResponderMAC` |
| kPqInitiatorMacInfo | `ECLIPTIX-OPAQUE-PQ-v1/InitiatorMAC` |

Префікс `ECLIPTIX-OPAQUE-v1/` ідентифікує версію протоколу. Постквантові мітки мають окремий префікс `ECLIPTIX-OPAQUE-PQ-v1/`, що забезпечує неможливість колізій між режимами.

### 4.5 Механізм захисту пам'яті

Реалізація включає багаторівневу систему захисту чутливих даних у оперативній пам'яті.

**Безпечний алокатор (`SecureAllocator<T>`).** C++ алокатор з концептом `SecurelyAllocatable`: пам'ять виділяється через `posix_memalign` з вирівнюванням до сторінки, блокується через `mlock` (запобігає swap), ініціалізується нулями. При звільненні --- `sodium_memzero`, `munlock`, `free`.

**Безпечний буфер (`SecureBuffer`).** RAII-обгортка з управлінням правами доступу: `make_readonly()` через `mprotect(PROT_READ)`, `make_noaccess()` через `mprotect(PROT_NONE)`. Забороняє копіювання, підтримує лише move-семантику.

**Детерміноване знищення.** `sodium_memzero` систематично застосовується для всіх проміжних значень: `randomized_pwd`, `oprf_output`, `prk`, `mac_key`, `dh1-dh3`, `kem_shared_secret`, `classical_ikm`, `transcript_hash`. Деструктор `ResponderState` затирає усі поля стану.

**Верифікація у постійному часі.** `crypto_verify_64` та `crypto_verify_32` реалізують побітове порівняння без ранніх виходів. Функція `util::is_all_zero` використовує акумуляторний підхід з побітовим АБО.

---
## 5. АНАЛІЗ БЕЗПЕКИ

Безпека гібридного протоколу Hybrid PQ-OPAQUE ґрунтується на композиції криптографічних механізмів, кожен з яких забезпечує окрему властивість захисту. У цьому розділі подано формальний аналіз ключових властивостей безпеки протоколу, розглянуто стійкість до відомих класів атак та проведено порівняння з іншими гібридними підходами до автентифікації та узгодження ключів.

**Рисунок 5.1** — Модель загроз Hybrid PQ-OPAQUE

```
┌─────────────────────────────────────────────────────────────────────┐
│                    МОДЕЛЬ ЗАГРОЗ (Threat Model)                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────┐                                    ┌──────────┐      │
│  │  Клієнт  │◄═══════ Відкритий канал ═══════►│  Сервер  │      │
│  │          │    (контрольований противником)     │          │      │
│  │ • пароль │         ┌───────────┐              │ • skS    │      │
│  │ • skC    │         │Противник A│              │ • OPRF k │      │
│  │ • ekC    │         │           │              │ • ekS    │      │
│  │ • kem_dk │         │ Здатності:│              │ • Envelope│     │
│  └──────────┘         │ • перехопл│              └──────────┘      │
│                       │ • підміна │                                 │
│                       │ • replay  │                                 │
│                       │ • DH oracle│  ← квантовий (Шор)            │
│                       │ • LTK leak │  ← компрометація сервера      │
│                       │ • DB dump  │  ← компрометація БД           │
│                       └───────────┘                                 │
│                                                                     │
│  Захист (AND-модель):                                              │
│  ┌─────────────────────┐  ┌─────────────────────┐                  │
│  │ Класичний: 3-DH     │  │ Постквантовий:      │                  │
│  │ dh1 = Cs · Ss       │  │ ML-KEM-768          │                  │
│  │ dh2 = Ss · Ce       │  │ (IND-CCA2, MLWE)    │                  │
│  │ dh3 = Se · Cs       │  │                     │                  │
│  │ (CDH-hard)          │  │ (Quantum-resistant)  │                  │
│  └────────┬────────────┘  └────────┬────────────┘                  │
│           └──────────┬─────────────┘                                │
│              HKDF-Extract(salt, dh1‖dh2‖dh3‖kem_ss)               │
│                      │                                              │
│              PRK → session_key, MAC keys                           │
│           Зламати = зламати DH ∧ зламати KEM                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.1 Формальний аналіз властивостей безпеки

Формальний аналіз безпеки Hybrid PQ-OPAQUE проводиться на основі game-based підходу з послідовністю ігор (game hopping). Базовий протокол OPAQUE має повне доведення безпеки у моделі Universally Composable (UC) PAKE, запропонованій Canetti [22] та розширеній Jarecki et al. [4]. Оскільки запропоноване гібридне розширення не модифікує структуру OPRF, конверта та фаз автентифікації (лише розширює вхідний ключовий матеріал для HKDF-Extract), UC-безпека базового OPAQUE зберігається за аргументом модульної композиції. Нижче наводимо game-based аргументи безпеки (security arguments) для ключових властивостей гібридного розширення. Модель передбачає наявність адаптивного ймовірнісного поліноміально обмеженого противника $\mathcal{A}$, який контролює мережу, може перехоплювати, модифікувати та повторно надсилати повідомлення, а також компрометувати довготривалі та ефемерні ключі сторін. Безпека протоколу зводиться до складності розв'язання задач Computational Diffie-Hellman (CDH) у групі Ristretto255, стійкості ML-KEM-768 до атак на основі Module-LWE [17], а також властивостей псевдовипадковості HKDF [33] та забудькуватої псевдовипадкової функції (OPRF) [5].

**Теорема 1** (Секретність паролю). *Нехай $\mathcal{A}$ — ймовірнісний поліноміально обмежений противник, який спостерігає протокольний транскрипт та має доступ до серверної бази даних (файл реєстрації). Тоді перевага $\mathcal{A}$ у визначенні паролю користувача $pw$ є нехтовно малою за умови: (1) забудькуватості OPRF на базі Ristretto255; (2) стійкості функції розтягування ключа Argon2id; (3) семантичної стійкості XSalsa20-Poly1305.*

*Доведення (ескіз).* Розглянемо послідовність ігор (game hopping), що зводить задачу визначення паролю до задач, складність яких є загальновизнаною.

**Гра 0.** Оригінальна гра безпеки, в якій противник $\mathcal{A}$ отримує транскрипт протоколу та запис реєстрації $\text{record} = (c\_u, \text{masking\_key}, \text{server\_public\_key}, k_u, P_u)$.

**Гра 1.** Замінюємо вихід OPRF $\text{rwd} = F_{k_s}(pw)$ на рівномірно випадковий елемент $\widetilde{\text{rwd}} \xleftarrow{\$} \{0,1\}^{512}$. Перехід є обчислювально нерозрізнимим за властивістю забудькуватості (obliviousness) протоколу OPRF [5]: клієнт надсилає сліпий елемент $\alpha = \text{Blind}(pw) = H'(pw) \cdot r$, де $r \xleftarrow{\$} \mathbb{Z}_q$, і сервер обчислює $\beta = \alpha^{k_s}$, не маючи можливості визначити $pw$ з $\alpha$ без розв'язання задачі CDH у групі Ristretto255. Формально:
$$|\Pr[S_1] - \Pr[S_0]| \leq \text{Adv}_{\text{OPRF}}^{\text{obliv}}(\mathcal{A}) \leq \text{Adv}_{\text{Ristretto255}}^{\text{CDH}}(\mathcal{A}).$$

**Гра 2.** Замінюємо вихід Argon2id($\widetilde{\text{rwd}}$) на рівномірно випадковий ключ $\widetilde{K} \xleftarrow{\$} \{0,1\}^{256}$. Функція Argon2id [30] з параметрами $m = 262144$ КБ (256 МБ), $t = 3$, $p = 1$ (MODERATE preset libsodium) забезпечує memory-hard розтягування ключа, що робить паралельний перебір економічно недоцільним. Вартість атаки з використанням ASIC оцінюється як $C_{\text{attack}} \geq m \cdot t \cdot C_{\text{mem}}$, де $C_{\text{mem}}$ — вартість одиниці пам'яті. За оцінками [30], при заданих параметрах вартість перебору одного паролю складає щонайменше $2^{40}$ операцій із залученням 256 МБ пам'яті. Перехід є обчислювально нерозрізнимим:
$$|\Pr[S_2] - \Pr[S_1]| \leq \text{Adv}_{\text{Argon2id}}^{\text{PRF}}(\mathcal{A}).$$

**Гра 3.** Замінюємо конверт $\text{Envelope} = \text{XSalsa20-Poly1305}.\text{Seal}(\widetilde{K}, \text{nonce}, \text{client\_private\_key})$ на шифрування випадкового рядка. За семантичною стійкістю (IND-CPA) автентифікованого шифрування XSalsa20-Poly1305 [35] з рівномірно випадковим ключем:
$$|\Pr[S_3] - \Pr[S_2]| \leq \text{Adv}_{\text{XSalsa20}}^{\text{IND-CPA}}(\mathcal{A}).$$

У Грі 3 пароль $pw$ інформаційно-теоретично незалежний від усіх спостережуваних величин, отже $\Pr[S_3] = 1/|\mathcal{D}|$, де $\mathcal{D}$ — словник паролів. Таким чином, перевага противника:
$$\text{Adv}^{\text{pw}}(\mathcal{A}) \leq \text{Adv}_{\text{Ristretto255}}^{\text{CDH}}(\mathcal{A}) + \text{Adv}_{\text{Argon2id}}^{\text{PRF}}(\mathcal{A}) + \text{Adv}_{\text{XSalsa20}}^{\text{IND-CPA}}(\mathcal{A}) + \frac{1}{|\mathcal{D}|}. \quad \blacksquare$$

**Теорема 2** (Пряма секретність — Forward Secrecy). *Hybrid PQ-OPAQUE забезпечує пряму секретність сесійного ключа: компрометація довготривалих ключів клієнта $C_s$ та сервера $S_s$ не дозволяє противнику $\mathcal{A}$ відновити сесійний ключ $K_{\text{session}}$ для раніше завершених сесій, за умови стійкості задачі CDH у Ristretto255 та IND-CCA стійкості ML-KEM-768.*

*Доведення (ескіз).* Сесійний ключ виводиться з комбінованого матеріалу:
$$\text{combined\_ikm} = \text{dh}_1 \| \text{dh}_2 \| \text{dh}_3 \| \text{kem\_ss},$$
де $\text{dh}_1 = S_s \cdot C_s$ (статичний-статичний), $\text{dh}_2 = S_s \cdot C_e$ (серверний статичний $\times$ клієнтський ефемерний), $\text{dh}_3 = S_e \cdot C_s$ (серверний ефемерний $\times$ клієнтський статичний), а $\text{kem\_ss}$ — спільний секрет ML-KEM-768.

Після компрометації $C_s, S_s$ противник знає $\text{dh}_1$. Однак для обчислення $\text{dh}_2 = S_s \cdot C_e$ необхідно знати ефемерний секретний ключ клієнта $c_e$, а для $\text{dh}_3 = S_e \cdot C_s$ — ефемерний секретний ключ сервера $s_e$. Оскільки ефемерні ключі генеруються заново для кожної сесії та видаляються після завершення, обчислення $\text{dh}_2$ або $\text{dh}_3$ зводиться до задачі CDH.

Крім того, $\text{kem\_ss}$ захищений IND-CCA стійкістю ML-KEM-768 [17]: для кожної сесії генерується свіжа ефемерна пара $(ek, dk)$, де $dk$ видаляється після декапсуляції. Навіть якщо зловмисник записав шифротекст $\text{kem\_ct}$, він не може відновити $\text{kem\_ss}$ без знання $dk$. За редукцією до задачі Module-LWE:
$$\text{Adv}^{\text{FS}}(\mathcal{A}) \leq \text{Adv}_{\text{Ristretto255}}^{\text{CDH}}(\mathcal{A}) + \text{Adv}_{\text{ML-KEM}}^{\text{IND-CCA}}(\mathcal{A}). \quad \blacksquare$$

Таким чином, пряма секретність забезпечується двома незалежними механізмами: ефемерним обміном Діффі-Гелмана на еліптичній кривій та ефемерною інкапсуляцією ML-KEM. Компрометація одного з механізмів не знижує рівень захисту, що забезпечується іншим.

**Теорема 3** (Взаємна автентифікація). *Hybrid PQ-OPAQUE забезпечує взаємну автентифікацію клієнта та сервера: ймовірність того, що противник $\mathcal{A}$ успішно видасть себе за легітимну сторону, є нехтовно малою за умови стійкості HMAC-SHA-512 як PRF та коректності верифікації MAC через crypto\_verify\_64.*

*Доведення (ескіз).* Після виведення PRK обидві сторони обчислюють MAC-ключі $K_{\text{mac}}^{S}$ та $K_{\text{mac}}^{C}$ за допомогою HKDF-Expand. Транскрипт $\tau$, що включає ефемерні відкриті ключі, нонси, статичні ключі, credential\_response, kem\_pk та kem\_ct, є спільним для обох сторін. Сервер обчислює $\text{server\_mac} = \text{HMAC-SHA-512}(K_{\text{mac}}^{S}, \text{HandshakeContext} \| \tau)$, а клієнт верифікує його. Аналогічно, клієнт обчислює $\text{client\_mac} = \text{HMAC-SHA-512}(K_{\text{mac}}^{C}, \text{HandshakeContext} \| \tau)$, що верифікується сервером.

Для підробки MAC без знання PRK (і, відповідно, $K_{\text{mac}}$) необхідно порушити стійкість HMAC-SHA-512 як PRF [33]. Включення всіх ефемерних та статичних елементів до транскрипту $\tau$ унеможливлює атаки з підміною відкритих ключів (Unknown Key-Share attacks) [32]. Використання функції crypto\_verify\_64 з постійним часом виконання для порівняння MAC-значень виключає витік інформації через часові бічні канали:
$$\text{Adv}^{\text{auth}}(\mathcal{A}) \leq \text{Adv}_{\text{HMAC-SHA-512}}^{\text{PRF}}(\mathcal{A}) + \frac{q_s}{2^{512}}, \quad \blacksquare$$
де $q_s$ — кількість сесій, а $2^{-512}$ — ймовірність випадкового вгадування MAC.

**Теорема 4** (Гібридна безпека — AND-модель). *Нехай $\text{combined\_ikm} = \text{dh}_1 \| \text{dh}_2 \| \text{dh}_3 \| \text{kem\_ss}$, і $\text{PRK} = \text{HKDF-Extract}(\text{PqCombinerContext} \| H(\tau), \text{combined\_ikm})$. Якщо хоча б одна з умов виконується: (a) класичний внесок $\text{dh}_1 \| \text{dh}_2 \| \text{dh}_3$ є обчислювально нерозрізнимим від рівномірного; або (b) $\text{kem\_ss}$ є обчислювально нерозрізнимим від рівномірного, — тоді PRK є обчислювально нерозрізнимим від рівномірно випадкового значення.*

*Доведення (ескіз).* Доведення використовує dual-PRF властивість HKDF-Extract, побудованого на HMAC-SHA-512 [33, 41]. Кравчик показав [33], що HMAC має dual-PRF властивість: якщо *або* ключ (salt), *або* повідомлення (IKM) є псевдовипадковим, то вихід HMAC є обчислювально нерозрізнимим від рівномірного. Ця властивість є фундаментальною для AND-моделі безпеки, оскільки дозволяє гарантувати псевдовипадковість PRK при стійкості хоча б одного компонента.

Розглянемо два випадки:

**Випадок (a).** Нехай $\text{dh}_1 \| \text{dh}_2 \| \text{dh}_3$ — псевдовипадковий (стійкість CDH). Тоді навіть якщо $\text{kem\_ss}$ повністю відомий противнику, $\text{combined\_ikm}$ містить щонайменше 96 байт (3 × 32 байти) псевдовипадкового матеріалу. За dual-PRF властивістю HKDF-Extract [33], якщо IKM є псевдовипадковим, PRK є псевдовипадковим незалежно від солі:
$$\text{Adv}^{\text{PRK}}(\mathcal{A}) \leq \text{Adv}_{\text{Ristretto255}}^{\text{CDH}}(\mathcal{A}) + \text{Adv}_{\text{HMAC}}^{\text{dual-PRF}}(\mathcal{A}).$$

**Випадок (b).** Нехай $\text{kem\_ss}$ — псевдовипадковий (IND-CCA стійкість ML-KEM-768). Оскільки $\text{kem\_ss}$ займає 32 байти у $\text{combined\_ikm}$, а HKDF-Extract використовує $\text{PqCombinerContext} \| H(\tau)$ як сіль (що включає специфічний контекст гібридного комбайнера), достатньо мін-ентропії $\text{kem\_ss}$ для того, щоб PRK був псевдовипадковим:
$$\text{Adv}^{\text{PRK}}(\mathcal{A}) \leq \text{Adv}_{\text{ML-KEM}}^{\text{IND-CCA}}(\mathcal{A}) + \text{Adv}_{\text{HMAC}}^{\text{dual-PRF}}(\mathcal{A}).$$

Об'єднуючи обидва випадки, отримуємо AND-модель гібридної безпеки: для порушення псевдовипадковості PRK противник має одночасно подолати *обидва* механізми — класичний DH *та* пост-квантовий KEM:
$$\text{Adv}^{\text{hybrid}}(\mathcal{A}) \leq \min\left(\text{Adv}_{\text{Ristretto255}}^{\text{CDH}}(\mathcal{A}), \ \text{Adv}_{\text{ML-KEM}}^{\text{IND-CCA}}(\mathcal{A})\right) + \text{Adv}_{\text{HMAC}}^{\text{dual-PRF}}(\mathcal{A}). \quad \blacksquare$$

Ця властивість є критичною для перехідного періоду, коли стійкість пост-квантових схем ще не підтверджена достатнім обсягом криптоаналізу: навіть у разі виявлення вразливостей у ML-KEM, безпека протоколу зберігається на рівні класичного OPAQUE на Ristretto255.

### 5.2 Стійкість до відомих атак

У цьому підрозділі систематично розглянуто стійкість Hybrid PQ-OPAQUE до основних класів атак, релевантних для протоколів автентифікації з паролем та узгодження ключів.

#### 5.2.1 Офлайн-атаки за словником (Offline Dictionary Attacks)

Офлайн-атака за словником є найбільш критичною загрозою для протоколів PAKE: противник, отримавши серверну базу даних або транскрипт протоколу, намагається перебрати словник паролів $\mathcal{D}$ без взаємодії з сервером. Hybrid PQ-OPAQUE протистоїть цій атаці на трьох рівнях.

По-перше, протокол OPRF [5] забезпечує, що сервер зберігає не хеш паролю, а результат обчислення $\text{rwd} = F_{k_s}(pw)$, де $k_s$ — секретний OPRF-ключ сервера. Без знання $k_s$ противник не може обчислити $\text{rwd}$ для жодного кандидата $pw' \in \mathcal{D}$, навіть маючи повний доступ до запису реєстрації. По-друге, функція розтягування Argon2id з параметрами $(m = 262144, t = 3, p = 1)$ (MODERATE preset) забезпечує memory-hard захист, що унеможливлює ефективний паралельний перебір на GPU та ASIC [30]. По-третє, конверт зашифрований алгоритмом XSalsa20-Poly1305 [35] з ключем, виведеним з $\text{rwd}$, що вимагає від противника коректного дешифрування для верифікації кандидата.

Комбінована вартість офлайн-атаки оцінюється як $C_{\text{offline}} = |\mathcal{D}| \cdot C_{\text{Argon2id}} \cdot C_{\text{XSalsa20}}$, що при словнику $|\mathcal{D}| = 10^{10}$ та часі виконання Argon2id $\approx 1$ с складає понад $10^{10}$ секунд — більше 300 років на одному процесорі.

#### 5.2.2 Атака "людина посередині" (Man-in-the-Middle, MITM)

Активний противник, що контролює канал зв'язку, може намагатися встановити окремі сесії з клієнтом та сервером, ретранслюючи та модифікуючи повідомлення. Hybrid PQ-OPAQUE протистоїть MITM-атакам завдяки кільком механізмам.

Транскрипт $\tau$ включає *всі* відкриті елементи обміну: ефемерні ключі DH ($C_e, S_e$), нонси (client\_nonce, server\_nonce), статичні відкриті ключі, credential\_response, kem\_pk та kem\_ct. MAC-значення обчислюються як $\text{HMAC-SHA-512}(K_{\text{mac}}, \tau)$, тому будь-яка модифікація будь-якого елемента транскрипту призведе до неспівпадіння MAC та негайного розриву з'єднання.

Крім того, включення kem\_pk та kem\_ct до транскрипту забезпечує зв'язування пост-квантового обміну з класичним: противник не може замінити KEM-шифротекст без порушення MAC, навіть якщо він здатний виконати атаку на рівні DH-обміну.

#### 5.2.3 Атака повторного відтворення (Replay Attack)

Replay-атака полягає у повторному надсиланні раніше перехоплених повідомлень для встановлення автентифікованої сесії. Захист забезпечується використанням ефемерних елементів: (1) клієнтський нонс client\_nonce $\xleftarrow{\$} \{0,1\}^{192}$; (2) серверний нонс server\_nonce $\xleftarrow{\$} \{0,1\}^{192}$; (3) ефемерний DH-ключ клієнта $C_e$; (4) ефемерний DH-ключ сервера $S_e$; (5) ефемерна KEM-пара $(ek, dk)$.

Повторне використання повідомлення першого раунду (CredentialRequest) з тим самим нонсом призведе до генерації сервером нового server\_nonce та нового $S_e$, тому combined\_ikm буде відрізнятися від оригінального. Відповідно, MAC-значення не співпадуть, і сесія буде відхилена. Ймовірність колізії нонсів при рівномірній генерації складає $2^{-192}$, що є нехтовно малою.

#### 5.2.4 Атака "збери зараз — розшифруй пізніше" (Harvest Now, Decrypt Later — HNDL)

Атака HNDL [13] є основною мотивацією для впровадження пост-квантової криптографії: противник записує поточний зашифрований трафік в очікуванні появи квантового комп'ютера, здатного подолати класичні криптосистеми. Hybrid PQ-OPAQUE забезпечує захист від цієї загрози завдяки включенню ML-KEM-768 у процес виведення ключа.

Навіть якщо квантовий противник $\mathcal{A}_Q$ здатний розв'язати задачу CDH за допомогою алгоритму Шора [9] та обчислити $\text{dh}_1, \text{dh}_2, \text{dh}_3$ з записаного транскрипту, для відновлення $\text{combined\_ikm}$ необхідно також визначити $\text{kem\_ss}$. ML-KEM-768 базується на задачі Module-LWE [17], для якої на сьогодні не відомі ефективні квантові алгоритми. За оцінками NIST [15], ML-KEM-768 забезпечує рівень безпеки, еквівалентний AES-192, навіть за наявності квантового комп'ютера.

Таким чином, записаний трафік Hybrid PQ-OPAQUE не може бути розшифрований квантовим противником, що робить атаку HNDL неефективною — на відміну від класичного OPAQUE, де всі три компоненти DH можуть бути обчислені алгоритмом Шора.

#### 5.2.5 Атака з компрометацією ключа (Key Compromise Impersonation — KCI)

Атака KCI [32] виникає, коли противник, який скомпрометував довготривалий секретний ключ сервера $s_s$, намагається видати себе за легітимного клієнта перед сервером (або навпаки). У Hybrid PQ-OPAQUE компрометація $s_s$ дозволяє обчислити $\text{dh}_1 = S_s \cdot C_s$ та $\text{dh}_2 = S_s \cdot C_e$, але *не* $\text{dh}_3 = S_e \cdot C_s$, оскільки ефемерний ключ $S_e$ є свіжим для кожної сесії.

Крім того, для імітації клієнта противнику необхідно обчислити client\_mac, що вимагає знання PRK. Оскільки PRK залежить від kem\_ss (через ефемерну KEM-пару, секретний ключ якої відомий лише легітимному клієнту), а також від $\text{dh}_3$ (через ефемерний ключ сервера $S_e$, секрет якого відомий лише легітимному серверу), KCI-атака є неуспішною.

Додатковий рівень захисту забезпечується тим, що автентифікація клієнта ґрунтується на знанні паролю через OPRF-протокол, а не лише на володінні довготривалим ключем. Це принципово відрізняє Hybrid PQ-OPAQUE від протоколів на основі сертифікатів.

#### 5.2.6 Атаки бічними каналами (Side-Channel Attacks)

Протокол включає кілька заходів захисту від атак бічними каналами:

1. **Постійний час порівняння MAC.** Функція crypto\_verify\_64 виконує побайтове порівняння 64-байтних MAC-значень у постійному часі, використовуючи бітову операцію XOR з акумуляцією, що виключає ранній вихід (early termination) [35]. Це унеможливлює timing-атаки на етап верифікації.

2. **Маскування відповіді.** Поле credential\_response обробляється з використанням masking\_key та masking\_nonce незалежно від того, чи знайдено запис користувача. При відсутності запису сервер генерує випадкову відповідь ідентичного формату, що унеможливлює enumeration-атаки (визначення існування облікового запису) [4].

3. **Скалярне множення у постійному часі.** Бібліотека libsodium реалізує операції над групою Ristretto255 з постійним часом виконання та без залежних від секрету розгалужень [35], що виключає timing- та cache-атаки на DH-обчислення.

4. **Захист ML-KEM.** Реалізація ML-KEM-768 у бібліотеці liboqs використовує арифметику з постійним часом для операцій Number Theoretic Transform (NTT) [35], що захищає від SPA/DPA-атак на постквантову складову.

#### 5.2.7 Атаки з підміною параметрів (Tampering Attacks)

Противник може намагатися модифікувати окремі компоненти повідомлень протоколу для нав'язування слабких параметрів або порушення цілісності обміну. Hybrid PQ-OPAQUE забезпечує захист від таких атак на кількох рівнях:

1. **Цілісність KEM-параметрів.** Відкритий ключ kem\_pk та шифротекст kem\_ct включені до транскрипту $\tau$, що захищається MAC. Підміна kem\_pk або kem\_ct призведе до неспівпадіння MAC та розриву з'єднання.

2. **Цілісність конверта.** Автентифіковане шифрування XSalsa20-Poly1305 забезпечує одночасно конфіденційність та цілісність конверта з довготривалим ключем клієнта. Будь-яка модифікація шифротексту буде виявлена при перевірці тегу автентифікації Poly1305.

3. **Downgrade-захист.** Фіксація алгоритмічного набору в ідентифікаторі контексту PqCombinerContext та включення його у виведення PRK виключає атаки з пониженням рівня безпеки. Сторони не можуть бути примушені до використання слабших параметрів без порушення цілісності транскрипту.

4. **Захист від підміни групи (Small Subgroup Attacks).** Використання групи Ristretto255 [29], яка є групою простого порядку без нетривіальних підгруп, виключає атаки з використанням елементів малих підгруп, характерні для реалізацій Curve25519 без валідації точок.

#### 5.2.8 Квантова стійкість OPRF-компонента

Важливо зазначити, що OPRF-компонент протоколу, реалізований на групі Ristretto255, **не є постквантово стійким**: квантовий противник, здатний розв'язати задачу CDH за допомогою алгоритму Шора [9], може обчислити OPRF-ключ $k_{\text{oprf}}$ зі спостережуваних елементів OPRF-протоколу. Це створює потенційний вектор атаки: маючи серверну базу даних (зашифрований конверт та OPRF-ключ) *і* квантовий комп'ютер, противник теоретично може здійснити офлайн-перебір паролів.

Проте ця загроза суттєво пом'якшується архітектурою протоколу OPAQUE:

1. **Argon2id як bottleneck.** Навіть при можливості обчислити $F_{k_{\text{oprf}}}(pw')$ для кандидата $pw'$, противнику необхідно виконати Argon2id з параметрами (3 ітерації, 256 МБ) для кожного кандидата. Квантові комп'ютери не дають переваги для memory-hard функцій [30], тому вартість перебору залишається $|\mathcal{D}| \cdot C_{\text{Argon2id}}$.

2. **Двоетапна верифікація.** Після Argon2id противник повинен розшифрувати конверт (XSalsa20-Poly1305 [35]) та перевірити, що отриманий приватний ключ відповідає збереженому публічному ключу. Це робить кожну спробу перебору обчислювально дорогою.

3. **Розмежування загроз.** Для здійснення цієї атаки противнику необхідні *одночасно*: (a) повний доступ до серверної бази даних; (b) квантовий комп'ютер, здатний зламати CDH на Ristretto255; (c) ресурси для memory-hard перебору словника. Ця комбінація є значно складнішою, ніж стандартна HNDL-атака на транспортний рівень.

4. **Шлях міграції.** Заміна Ristretto255-OPRF на постквантово стійкий OPRF (наприклад, на основі ізогеній або решіток) є напрямком подальших досліджень і не потребує зміни решти архітектури протоколу.

Таким чином, гібридна конструкція PQ-OPAQUE **повністю захищає транспортний рівень** (ключовий обмін) від квантових атак, тоді як OPRF-компонент залишається класичним, що є *свідомим архітектурним рішенням*: захист від HNDL-атаки на перехоплений трафік (основна квантова загроза) забезпечений, а атака на OPRF потребує додаткової компрометації серверної бази даних і залишається загальмованою Argon2id.

### 5.3 Порівняння з гібридними підходами

Для контекстуалізації запропонованого рішення проведемо порівняльний аналіз Hybrid PQ-OPAQUE з іншими відомими гібридними протоколами, що поєднують класичну та пост-квантову криптографію.

**TLS 1.3 Hybrid** [18] — розширення протоколу TLS 1.3, що додає пост-квантовий KEM до класичного ECDH-обміну. Гібридний підхід реалізується через механізм узгодження ключів (key share), де клієнт надсилає як ECDH-, так і KEM-компоненти у повідомленні ClientHello. Протокол забезпечує автентифікацію через PKI-сертифікати та не підтримує парольну автентифікацію.

**Signal PQXDH** [19] — розширення протоколу Extended Triple Diffie-Hellman (X3DH), що використовується в Signal Protocol для початкового встановлення сесії. PQXDH додає ML-KEM-768 ключ до набору prekeys, забезпечуючи пост-квантовий захист початкового обміну. Протокол орієнтований на асинхронну комунікацію та не передбачає серверної автентифікації.

**WireGuard PQ** [20] — експериментальне розширення протоколу WireGuard VPN, що додає пост-квантовий KEM до Noise IK handshake. Реалізація використовує Classic McEliece або Kyber як додатковий KEM-компонент. Протокол забезпечує автентифікацію на основі статичних відкритих ключів.

**Таблиця 5.1** — Порівняння гібридних протоколів з пост-квантовим захистом

| Властивість | OPAQUE (класичний) | TLS 1.3 Hybrid | Signal PQXDH | WireGuard PQ | Hybrid PQ-OPAQUE |
|---|---|---|---|---|---|
| Класична основа | 3DH (Ristretto255) | ECDH (P-256/X25519) | X3DH (X25519) | Noise IK (X25519) | 3DH (Ristretto255) |
| PQ-компонент | — | ML-KEM-768 | ML-KEM-768 | ML-KEM-768 / McEliece | ML-KEM-768 |
| Модель безпеки | Classical | AND | AND | AND | AND |
| Тип автентифікації | PAKE (пароль + OPRF) | PKI-сертифікати | Prekey bundle | Статичні ключі | PAKE (пароль + OPRF) |
| Серверна автентифікація | Так (MAC + 3DH) | Так (сертифікат) | Ні | Так (статичний ключ) | Так (MAC + 3DH) |
| Клієнтська автентифікація | Так (OPRF + MAC) | Опціонально | Так (prekey) | Так (статичний ключ) | Так (OPRF + MAC) |
| Пряма секретність | Так | Так | Так | Ні (статичні ключі) | Так |
| PQ пряма секретність | Ні | Так | Так | Ні | Так |
| Захист від офлайн-перебору | Так (OPRF + Argon2id) | Не застосовно | Не застосовно | Не застосовно | Так (OPRF + Argon2id) |
| Захист від HNDL | Ні | Так | Так | Так | Так |
| Захист від KCI | Так | Частково | Ні | Частково | Так |
| Захист паролю | Так | Ні (PKI) | Ні (ключі) | Ні (ключі) | Так |
| Кількість раундів | 1.5-RTT | 1-RTT | 0-RTT (async) | 1-RTT | 1.5-RTT |
| Розмір handshake, байт | 440 | ~3200 | ~2400 | ~2800 | 2712 |

Як видно з таблиці, Hybrid PQ-OPAQUE зберігає всі властивості безпеки класичного OPAQUE (захист паролю, стійкість до офлайн-перебору, KCI-захист, взаємна автентифікація) та додає постквантову стійкість — PQ forward secrecy та захист від HNDL-атак. Серед гібридних протоколів Hybrid PQ-OPAQUE є єдиним, що забезпечує парольну автентифікацію з OPRF та Argon2id — механізмами, специфічними для aPAKE та відсутніми в протоколах на основі PKI або статичних ключів.

Водночас, Hybrid PQ-OPAQUE має найбільший розмір handshake (2712 байт) та потребує 1.5-RTT (3 повідомлення) для завершення автентифікації, що є компромісом за додаткові властивості безпеки. Проте, як було показано у Розділі 4, накладні витрати є прийнятними для типових сценаріїв використання.

Варто також зазначити, що TLS 1.3 Hybrid [18] та Hybrid PQ-OPAQUE вирішують принципово різні задачі: перший забезпечує захист транспортного рівня з PKI-автентифікацією, тоді як другий — парольну автентифікацію без довіреної третьої сторони. У практичних системах ці протоколи можуть використовуватися комплементарно: TLS 1.3 Hybrid для захисту каналу, а Hybrid PQ-OPAQUE — для автентифікації користувача на прикладному рівні [6, 18].

Signal PQXDH [19] є найближчим аналогом з точки зору криптографічної конструкції (обидва протоколи використовують варіанти Triple-DH з додаванням KEM), проте відрізняється відсутністю серверної автентифікації та орієнтацією на асинхронний обмін повідомленнями. WireGuard PQ [20] забезпечує автентифікацію на основі статичних ключів, що вимагає попереднього безпечного розповсюдження ключів та не забезпечує прямої секретності у стандартному режимі.

Таким чином, Hybrid PQ-OPAQUE заповнює нішу серед гібридних протоколів, забезпечуючи пост-квантовий захист для сценарію парольної автентифікації — задачі, яка не адресується жодним з існуючих гібридних рішень.

### 5.4 Формальна верифікація у системі ProVerif

#### 5.4.1 Методологія та модель загроз

На доповнення до теоретичного аналізу безпеки (підрозд. 5.1–5.3), проведено формальну верифікацію протоколу Hybrid PQ-OPAQUE у системі автоматичного доведення ProVerif 2.05 [36]. ProVerif реалізує символьну модель Dolev–Yao [37], в якій криптографічні примітиви вважаються ідеальними (perfect cryptography assumption): функції шифрування, MAC та деривації ключів трактуються як довільні функції без алгебраїчних вразливостей; єдині знання противника — ті, що він явно отримує по відкритому каналу.

**Модель противника.** Противник $\mathcal{A}$ у символьній моделі:
- контролює весь мережевий трафік (перехоплення, підміна, повторна передача);
- може ініціювати довільну кількість паралельних та послідовних сесій;
- має доступ до серверної бази даних (OPRF-ключ та зашифрований конверт);
- може компрометувати довготривалі ключі сервера ($S_s$).

**Обмеження символьної моделі.** Символьна верифікація не охоплює атаки через бічні канали, статистичну нерозрізнимість ключового матеріалу (computational indistinguishability) або конкретні параметри безпеки. Ці аспекти адресуються теоремами 1–4 (підрозд. 5.1) та результатами емпіричного тестування (розд. 6).

#### 5.4.2 Моделювання протоколу

Верифікація реалізована за допомогою двох ProVerif-моделей, що розмежовують властивості секретності та автентифікації.

**Модель секретності** (`hybrid_pq_opaque.pv`). Охоплює повний цикл протоколу: реєстрацію через безпечний канал `secure_reg` та необмежену кількість автентифікаційних сесій на відкритому каналі `c`. Критичне моделювання — явна компрометація довготривалого ключа сервера:

```proverif
( !ClientAuth(secret_pwd, pkS)
| !ServerAuth(skS, pkS, record_stored2, oprf_key_stored)
| (event ServerLTKCompromised(pkS); out(c, skS))
)
```

Включення події `ServerLTKCompromised` дозволяє верифікувати найсильніші форми секретності: властивість залишається верифікованою навіть коли $S_s$ відомий противнику.

**Модель автентифікації** (`hybrid_pq_opaque_auth.pv`). Для верифікації властивостей correspondence (автентифікаційних запитів) використано спрощену модель з абстрагованим OPRF та явними конструкторами для транскрипту:

```proverif
fun make_transcript(point, point, nonce, nonce, point, point, kem_pk, kem_ct): bitstring.
fun hkdf_extract4(key, key, key, key): key.
```

Ця абстракція зберігає ключовий інваріант протоколу — **прив'язку транскрипту** (transcript binding): session key пов'язаний із конкретними значеннями всіх публічних елементів обміну, включаючи постквантовий відкритий ключ та шифротекст. Використання двох моделей є стандартною практикою при верифікації складних протоколів [38, 39].

#### 5.4.3 Результати верифікації

Верифікація виконана на платформі macOS Darwin 25.2.0 (Apple M1 Pro). ProVerif 2.05 встановлено через систему OPAM (OCaml 5.4.0).

**Запит PV-1: Секретність сесійного ключа.**

```proverif
free sess_key_test: key [private].
query attacker(sess_key_test).
```

ProVerif будує дерево дедукції для всіх можливих стратегій противника та перевіряє, чи може `sess_key_test` стати досяжним (reachable) фактом. Результат верифікації:

```
RESULT not attacker(sess_key_test[]) is true.
```

Цей результат підтверджує, що в символьній моделі Dolev–Yao жодна стратегія противника не дозволяє вивести сесійний ключ із публічно спостережуваного трафіку та серверної бази даних (включаючи $S_s$). Формально: $\forall \mathcal{A}$ (Dolev–Yao): $\text{sess\_key\_test} \notin \text{Derivable}(\mathcal{A}, \text{Transcript})$.

**Запит PV-2: Секретність паролю.**

```proverif
free secret_pwd: password [private].
query attacker(secret_pwd).
```

Результат:

```
RESULT not attacker(secret_pwd[]) is true.
```

Верифікація підтверджує, що символьний противник не може вивести пароль навіть при компрометації серверного ключа. Це є формальним підтвердженням властивості offline dictionary attack resistance: пароль ніколи не передається у відкритому вигляді, а зашифрований конверт $\text{Envelope} = \text{AEnc}(K_{\text{env}}, \text{nonce}, (S_s, C_s, \text{pk}_C))$ захищений ключем, що виводиться з виходу OPRF та Argon2id — без знання паролю цей ключ нерозрізнимий від випадкового.

**Запит PV-3: Відповідність клієнт→сервер.**

```proverif
query pkC: point, pkS: point, sk: key;
  event(ClientCompletesAuth(pkC, pkS, sk))
  ==> event(ServerAcceptsAuth(pkS, pkC, sk)).
```

Результат:

```
RESULT event(ClientCompletesAuth(pkC_2,pkS_1,sk)) ==>
       event(ServerAcceptsAuth(pkS_1,pkC_2,sk)) is true.
```

Ця властивість correspondence гарантує, що кожен факт успішного завершення автентифікації на стороні клієнта (верифікація server MAC, відправка KE3) обов'язково передує участі легітимного сервера, який прийняв ту саму сесію із тим самим ключем. Верифікація виключає сценарій, в якому клієнт вважає автентифікацію успішною без реальної участі сервера.

**Запит PV-4: Відповідність сервер→клієнт.**

```proverif
query pkC: point, pkS: point, sk: key;
  event(ServerCompletesAuth(pkS, pkC, sk))
  ==> event(ClientStartsAuth(pkC, pkS)).
```

Результат:

```
RESULT event(ServerCompletesAuth(pkS_1,pkC_2,sk)) ==>
       event(ClientStartsAuth(pkC_2,pkS_1)) is true.
```

Верифікація підтверджує, що сервер не може завершити автентифікацію (верифікувати client MAC у KE3) без попереднього ініціювання сесії легітимним клієнтом. Це виключає атаки імперсонації клієнта з боку активного мережевого противника.

**Запит PV-5: Ін'єктивна взаємна автентифікація (стійкість до атак повторного відтворення).**

```proverif
query pkC: point, pkS: point, sk: key;
  inj-event(ServerCompletesAuth(pkS, pkC, sk))
  ==> inj-event(ClientCompletesAuth(pkC, pkS, sk)).
```

Результат:

```
RESULT inj-event(ServerCompletesAuth(pkS_1,pkC_2,sk)) ==>
       inj-event(ClientCompletesAuth(pkC_2,pkS_1,sk)) is true.
```

Ін'єктивна (injective) властивість відповідності є суворішою за просту correspondence: вона встановлює **ін'єктивне відображення** між подіями завершення сесії сервером та подіями завершення сесії клієнтом. Формально: якщо сервер завершив дві різні сесії, то для них існують два різних, унікальних завершення на стороні клієнта. Це безпосередньо виключає **атаки повторного відтворення (replay attacks)**: противник не може змусити сервер завершити нову сесію, повторно надіславши перехоплений KE3 від попередньої сесії, оскільки кожна сесія містить унікальні ефемерні ключі та нонси, пов'язані транскриптом.

#### 5.4.4 Зведена таблиця результатів верифікації

| № | Властивість безпеки | Модель ProVerif | Результат |
|---|---------------------|-----------------|-----------|
| PV-1 | Секретність сесійного ключа (incl. LTK compromise) | `hybrid_pq_opaque.pv` | ✓ `true` |
| PV-2 | Секретність паролю (incl. server DB compromise) | `hybrid_pq_opaque.pv` | ✓ `true` |
| PV-3 | Відповідність клієнт→сервер | `hybrid_pq_opaque_auth.pv` | ✓ `true` |
| PV-4 | Відповідність сервер→клієнт | `hybrid_pq_opaque_auth.pv` | ✓ `true` |
| PV-5 | Ін'єктивна взаємна автентифікація | `hybrid_pq_opaque_auth.pv` | ✓ `true` |

Усі п'ять запитів підтверджено. Жодних атак або контрприкладів у символьній моделі не виявлено.

#### 5.4.5 Зв'язок із теоретичними теоремами

Результати формальної верифікації у ProVerif корелюють із теоретичними теоремами підрозд. 5.1:

- **PV-1** є символьним аналогом **Теореми 2** (Пряма секретність): відсутність ефемерних ключів у знаннях противника після закінчення сесії унеможливлює відновлення сесійного ключа навіть при компрометації довготривалих ключів.

- **PV-2** є символьним аналогом **Теореми 1** (Секретність паролю): ланцюжок OPRF → Argon2id → XSalsa20-Poly1305 не розкриває пароль жодній стороні протоколу.

- **PV-3, PV-4** є символьним аналогом **Теореми 3** (Взаємна автентифікація): MAC на основі транскрипту зі спільним ключовим матеріалом забезпечує автентифікацію обох сторін.

- **PV-5** (ін'єктивна відповідність) є більш сильним твердженням, що не має прямого аналога в підрозд. 5.1, та підтверджує стійкість до атак повторного відтворення на символьному рівні.

Формальна верифікація у ProVerif не замінює, але доповнює і посилює теоретичний аналіз безпеки: вона виключає широкий клас логічних помилок у конструкції протоколу, що не завжди очевидні з редукційних доведень.

#### 5.4.6 Примітки щодо верифікації AND-моделі

Запит PV-1 верифікує секретність сесійного ключа при умові, що противник може отримати довготривалий ключ сервера $S_s$. Оскільки в символьній моделі всі криптографічні операції є ідеальними, пряма верифікація AND-моделі (теорема 4) виходить за межі Dolev–Yao символіки — вона потребує обчислювальної моделі (наприклад, CryptoVerif [40]). Тим не менш, структура моделі явно відображає AND-властивість: сесійний ключ виводиться з `hkdf_extract4(dh1, dh2, dh3, kem_ss)`, де `kem_ss` є незалежним від DH-компонентів символьним атомом. У символьній моделі це означає, що для отримання сесійного ключа противник має отримати **обидва** компоненти — класичний ($\text{dh}_1, \text{dh}_2, \text{dh}_3$) та постквантовий ($\text{kem\_ss}$) — що є недосяжним без контролю над відповідними секретними ключами. Результат PV-1 `is true` підтверджує цю структурну властивість.

### 5.5 Символьна модель у Tamarin Prover

На доповнення до автоматичної верифікації у ProVerif, побудовано символьну модель протоколу Hybrid PQ-OPAQUE у системі Tamarin Prover [39] (`hybrid_pq_opaque.spthy`, 520 рядків). На відміну від ProVerif, Tamarin дозволяє явно моделювати глобальний стан сервера, часові обмеження та складніші теоретико-ігрові сценарії.

**Структура моделі.** Модель включає:
- правила реєстрації клієнта та зберігання записів на сервері;
- правила генерації KE1 (з ефемерними DH та KEM ключами), KE2 (3-DH + KEM Encaps + MAC) та KE3 (верифікація + MAC);
- правила компрометації ефемерних та довготривалих ключів;
- 8 лем безпеки та 1 допоміжну лему (sanity check).

**Сформульовані леми:**

| № | Лема | Властивість |
|---|------|-------------|
| 1 | `session_key_secrecy` | Секретність сеансового ключа |
| 2 | `password_secrecy` | Секретність паролю |
| 3 | `forward_secrecy_classical` | Класична пряма секретність (компрометація LTK) |
| 4 | `pq_forward_secrecy` | Постквантова пряма секретність (компрометація KEM SK) |
| 5 | `mutual_authentication_server_to_client` | Автентифікація сервер→клієнт |
| 6 | `mutual_authentication_client_to_server` | Автентифікація клієнт→сервер |
| 7 | `and_model_security` | AND-модель: безпека при компрометації одного примітиву |
| 8 | `offline_dictionary_resistance` | Стійкість до офлайн-атак за словником |

Модель Tamarin успішно скомпільована та завантажена. Усі 8 лем безпеки та 1 допоміжну лему (sanity check: `protocol_functional` — існування успішної сесії) верифіковано з результатом `verified`. Автоматичне доведення виконано за допомогою евристик `--heuristic=o "--oraclename=oracle.py"` для оптимізації пошуку; леми `session_key_secrecy`, `password_secrecy`, `forward_secrecy_classical`, `pq_forward_secrecy`, `mutual_authentication_server_to_client`, `mutual_authentication_client_to_server`, `and_model_security`, `offline_dictionary_resistance` — усі підтверджені.

Лема `and_model_security` є унікальною серед формальних моделей PAKE-протоколів: вона моделює сценарій, у якому противник може компрометувати довготривалі ключі (зокрема, через квантовий оракул для DH), та перевіряє, що сеансовий ключ залишається секретним за умови збереження ефемерних секретів обох сторін. Формально: `not (Ex #j. RevealEphemeral(C) @ #j) & not (Ex #j. RevealEphemeral(S) @ #j) ==> not (Ex #k. K(sk) @ #k)`. Правило `Reveal_Ephemeral_Server` видає обидва ефемерні секрети ($S_e$ та `kem_rand`), що моделює повну компрометацію ефемерного стану.

Лема `offline_dictionary_resistance` відрізняється від `password_secrecy` наявністю додаткової умови `CorruptDB(S, C)` — вона перевіряє, що пароль залишається секретним навіть при повній компрометації серверної бази даних (зашифрований конверт та OPRF-ключ).

**Зв'язок ProVerif та Tamarin.** Дві системи верифікації забезпечують взаємодоповнюючі гарантії: ProVerif ефективно верифікує необмежену кількість сесій з автоматичним доведенням (5/5 запитів підтверджено), тоді як Tamarin дозволяє формулювати більш гнучкі леми з явним моделюванням часових обмежень та глобального стану. Використання обох систем є стандартною практикою при верифікації критичних криптографічних протоколів [38].

---

## 6. РЕАЛІЗАЦІЯ ТА ЕКСПЕРИМЕНТАЛЬНА ОЦІНКА

### 6.1 Архітектура реалізації

Для практичної валідації запропонованого гібридного протоколу PQ-OPAQUE було розроблено програмну бібліотеку **ecliptix-opaque** мовою C++23 із забезпеченням крос-платформної сумісності для операційних систем macOS, Linux, Windows, а також мобільних платформ iOS та Android. Вибір стандарту C++23 обумовлений наявністю сучасних засобів безпечного управління пам'яттю, зокрема конструкцій `std::expected`, `std::span`, а також покращених механізмів `constexpr`-обчислень, що дозволяють виконувати частину криптографічних перевірок на етапі компіляції.

Бібліотека побудована на двох основних криптографічних залежностях:

- **libsodium 1.0.20+** [35] — для класичних криптографічних примітивів: операцій над групою Ristretto255 (скалярне множення, хешування на криву), OPRF на основі Ristretto255-SHA512, автентифікованого шифрування XSalsa20-Poly1305, ключової функції розтягування Argon2id, а також допоміжних функцій безпечного порівняння та очищення пам'яті;
- **liboqs 0.12.0+** [35] — для постквантових примітивів, зокрема механізму інкапсуляції ключів ML-KEM-768 (FIPS 203), що забезпечує IND-CCA2 безпеку на основі задачі Module-LWE.

Архітектура бібліотеки організована за модульним принципом із чітким розділенням відповідальностей на три рівні:

**Рівень ядра (core).** Містить модулі, що реалізують окремі криптографічні примітиви та допоміжні операції:
- `crypto.cpp` — обгортки над функціями libsodium для операцій Діффі — Геллмана на Ristretto255, HKDF-Expand/Extract на основі SHA-512, автентифікованого шифрування конвертів;
- `oprf.cpp` — реалізація протоколу забудькуватої псевдовипадкової функції (OPRF) за схемою Ristretto255-SHA512, включаючи операції засліплення, обчислення та фіналізації;
- `pq_kem.cpp` — інтерфейс до ML-KEM-768 через liboqs: генерація ключової пари, інкапсуляція та декапсуляція, а також гібридний комбінатор `CombineSharedSecrets` на основі HKDF;
- `envelope.cpp` — формування та розкриття криптографічного конверта, що містить зашифровані довготривалі ключі клієнта;
- `memory.cpp` — реалізація класу `SecureAllocator<T>`, що забезпечує блокування сторінок пам'яті через `mlock()` та гарантоване очищення через `sodium_memzero()` при звільненні.

**Рівень протоколу.** Реалізує логіку ініціатора (клієнта) та відповідача (сервера) у вигляді кінцевих автоматів зі станами `INIT`, `WAIT_KE2`, `DONE` для ініціатора та `INIT`, `WAIT_KE3`, `DONE` для відповідача. Кожен перехід стану валідує вхідне повідомлення та виконує відповідні криптографічні операції. Стани зберігаються у структурах із захищеною пам'яттю, що унеможливлює витік проміжних секретних значень.

**Рівень інтероперабельності (interop).** Забезпечує інтеграцію з іншими мовами програмування та платформами:
- C API (`extern "C"` експорти) — для використання з будь-якою мовою, що підтримує виклики зовнішніх функцій (FFI);
- JNI-обгортки — для платформи Android, що надають Java/Kotlin-інтерфейс до ядра бібліотеки;
- .NET NuGet-пакети — для інтеграції з платформою .NET через P/Invoke;
- Swift Package — для платформ iOS та macOS із нативною інтеграцією через Swift Package Manager.

Тестування реалізації виконується за допомогою фреймворку **Catch2 v3.4.0** з використанням BDD-стилю сценаріїв (`SCENARIO`/`GIVEN`/`WHEN`/`THEN`). Тестове покриття включає: модульні тести кожного криптографічного примітиву, інтеграційні тести повного циклу реєстрації та автентифікації, тести на некоректні вхідні дані (невалідні точки кривої, повідомлення неправильної довжини, повторне використання стану), а також стрес-тести з великою кількістю послідовних сесій для виявлення витоків пам'яті.

Система збірки побудована на **CMake** з управлінням залежностями через **vcpkg**. Для підвищення стійкості до атак на рівні реалізації застосовано наступні прапорці компіляції:

- `-fstack-protector-strong` — захист стеку з канарковими значеннями для функцій, що містять локальні буфери;
- `-D_FORTIFY_SOURCE=3` — перевірки буферів на етапі виконання для стандартних функцій бібліотеки;
- `-fPIC` — позиційно-незалежний код для захисту від атак на основі відомих адрес;
- `-Wl,-z,relro,-z,now` — повний RELRO для захисту таблиці GOT від перезапису після завантаження.

### 6.2 Оцінка продуктивності

Ключовою характеристикою будь-якого протоколу автентифікації є накладні витрати на передачу даних, оскільки вони безпосередньо впливають на затримку в мережевих середовищах з обмеженою пропускною здатністю. У таблиці 6.1 наведено порівняння розмірів повідомлень класичного протоколу OPAQUE (на основі виключно Ristretto255) та запропонованого гібридного PQ-OPAQUE.

**Таблиця 6.1** — Порівняння розмірів повідомлень протоколів OPAQUE та Hybrid PQ-OPAQUE

| Повідомлення | Classic OPAQUE, байт | Hybrid PQ-OPAQUE, байт | Додаткові витрати, байт | Джерело витрат |
|:---|:---:|:---:|:---:|:---|
| KE1 (клієнт → сервер) | 88 | 1272 | +1184 | Публічний ключ ML-KEM-768 (`kem_pk`, 1184 байт) |
| KE2 (сервер → клієнт) | 288 | 1376 | +1088 | Шифротекст ML-KEM-768 (`kem_ct`, 1088 байт) |
| KE3 (клієнт → сервер) | 64 | 64 | 0 | MAC підтвердження (незмінний) |
| **Всього** | **440** | **2712** | **+2272 (+516%)** | — |

Аналіз таблиці 6.1 дозволяє зробити кілька важливих спостережень.

По-перше, додаткові витрати повністю пояснюються розмірами артефактів ML-KEM-768: публічний ключ (1184 байт) додається до повідомлення KE1, а шифротекст інкапсуляції (1088 байт) — до повідомлення KE2. Повідомлення KE3 залишається незмінним, оскільки воно містить лише MAC-тег підтвердження, обчислений над уніфікованою стенограмою, незалежно від способу виведення сесійного ключа.

По-друге, абсолютне значення додаткових витрат у 2272 байт є прийнятним для переважної більшості практичних сценаріїв. Сумарний обсяг гібридного обміну (2712 байт) значно менший за типовий MTU Ethernet (1500 байт × 2 фрагменти) та є порівнянним із розміром типового TLS-рукостискання (4000–8000 байт). У мобільних мережах 4G/5G із типовою пропускною здатністю від 10 Мбіт/с передача додаткових 2.3 КБ потребує менше 0.2 мс, що є непомітним для користувача.

По-третє, кількість раундів обміну повідомленнями залишається незмінною: 3 повідомлення, що відповідає 1.5 кругових проходів (RTT). Це є критично важливим, оскільки саме мережева затримка (а не обсяг даних) зазвичай домінує у загальному часі автентифікації. Для типового RTT у 50–100 мс загальна затримка протоколу складає 75–150 мс незалежно від того, чи використовується класичний, чи гібридний варіант.

Окремо слід зазначити, що фаза реєстрації має **нульові постквантові витрати**, оскільки ефемерна ключова пара ML-KEM генерується лише під час автентифікації. Файл запису (registration record), що зберігається на сервері, має ідентичний формат і розмір у класичному та гібридному варіантах протоколу.

**Обчислювальна продуктивність.** Для оцінки обчислювальної складності проведено систематичне вимірювання на платформі Apple M1 Pro (10 ядер, 16 ГБ RAM, macOS Darwin 25.2.0, AppleClang 17, Release -O3, одне ядро). Результати наведено у таблиці 6.2.

**Таблиця 6.2** — Мікробенчмарки криптографічних примітивів (Apple M1 Pro, одне ядро)

| Операція | Середній час | Примітка |
|:---|:---:|:---|
| Скалярне множення Ristretto255 (одне DH) | 43.7 мкс | libsodium, постійний час |
| Три операції 3-DH (dh1 + dh2 + dh3) | ~131 мкс | 3 × 43.7 мкс |
| ML-KEM-768 KeyGen | 55.3 мкс | liboqs, генерація ефемерної пари |
| ML-KEM-768 Encapsulation | 67.2 мкс | Серверна сторона |
| ML-KEM-768 Decapsulation | 53.8 мкс | Клієнтська сторона |
| Гібридний комбінатор HKDF | 5.8 мкс | HKDF-Extract(salt, IKM) |
| Argon2id (MODERATE: 3 ітерації, 256 МБ) | ~585 мс | Домінує у загальному часі |

Повний раунд ML-KEM-768 (KeyGen + Encaps або Decaps) складає 55.3 + 67.2 = 122.5 мкс, що є **порівнянним** з трьома операціями Діффі--Геллмана на Ristretto255 (~131 мкс). Цей результат демонструє, що постквантовий компонент не є "вузьким місцем" протоколу — він обчислювально еквівалентний класичному обміну ключами.

**Рисунок 6.1** — Розподіл обчислювального часу автентифікації клієнта (KE3)

```
Загальний час автентифікації клієнта: ~586 мс
┌────────────────────────────────────────────────────────────────────┐
│                                                                    │
│  Argon2id (256 МБ, 3 ітерації)                                   │
│  ██████████████████████████████████████████████████████████ 585 мс │
│  ↑ 99.8% загального часу                                         │
│                                                                    │
├────────────────────────────────────────────────────────────────────┤
│  Решта операцій (~1 мс, масштабовано ×500):                       │
│                                                                    │
│  3-DH (3×Ristretto255)  ████████████████████████████  131 мкс     │
│  ML-KEM Decaps           ██████████████               53.8 мкс    │
│  ML-KEM KeyGen           ██████████████               55.3 мкс    │
│  OPRF Finalize           ████████                     ~30 мкс     │
│  HKDF-Extract+Expand     ██                           5.8 мкс     │
│  MAC compute+verify      █                            ~3 мкс      │
│                                                                    │
│  PQ overhead: ~0.12 мс (0.02% від загального часу)                │
└────────────────────────────────────────────────────────────────────┘
```

**Макробенчмарки фаз протоколу:**

- **Генерація KE1 (клієнт)**: ~0.1 мс (OPRF blind + ефемерні ключі DH + KEM KeyGen)
- **Генерація KE2 (сервер)**: ~0.33 мс (3-DH + KEM Encaps + HKDF + MAC)
- **Генерація KE3 (клієнт)**: ~586 мс (Argon2id + OPRF finalize + 3-DH + KEM Decaps + MAC verify)
- **Server Finish**: ~0.07 мс (MAC verify)

Ключова функція розтягування Argon2id домінує у загальному часі автентифікації клієнта, складаючи 99.8% обчислювального навантаження. Постквантова складова (ML-KEM) додає ~0.12 мс, що є непомітним на тлі 585 мс Argon2id. Ця характеристика є фундаментальною перевагою протоколу OPAQUE та його гібридного розширення: обчислювальна вартість визначається параметрами захисту від перебору паролів (KSF), а не криптографічними примітивами обміну ключами.

**Серверна пропускна здатність.** При серверному розгортанні з кешованими записами реєстрації операція Argon2id виконується виключно на стороні клієнта. Сервер виконує лише операції DH, KEM та MAC, що потребують сумарно ~0.33 мс на один KE2. Виміряна серверна пропускна здатність становить ~3010 операцій генерації KE2 на секунду (одне ядро), що забезпечує високу масштабованість: при горизонтальному масштабуванні на 8-ядерному сервері — до ~24 000 автентифікацій на секунду.

### 6.3 Оцінка безпеки реалізації

Окрім теоретичного аналізу безпеки протоколу, критичне значення має безпека конкретної реалізації. У бібліотеці ecliptix-opaque застосовано комплекс заходів для протидії атакам на рівні реалізації.

**Захист пам'яті.** Реалізовано шаблонний клас `SecureAllocator<T>`, що є стандартним алокатором C++ із додатковими гарантіями безпеки. При виділенні пам'яті для чутливих даних (секретні ключі, проміжні значення OPRF, спільні секрети DH та KEM) алокатор викликає системну функцію `mlock()` для блокування сторінок фізичної пам'яті та запобігання їх вивантаженню у файл підкачки (swap). При звільненні пам'яті гарантовано виконується `sodium_memzero()` — функція libsodium, що виконує обнулення пам'яті способом, стійким до оптимізацій компілятора. Це запобігає ситуації, коли компілятор видаляє «зайве» обнулення буфера, що більше не використовується (dead store elimination). Усі контейнери, що зберігають секретні дані, параметризовані типом `SecureAllocator`, наприклад: `std::vector<uint8_t, SecureAllocator<uint8_t>>`.

Життєвий цикл чутливих даних суворо контролюється за допомогою RAII-ідіоми (Resource Acquisition Is Initialization): секретні значення автоматично обнуляються при виході зі scope відповідної функції або при знищенні об'єкта стану протоколу. Це виключає можливість «забутих» секретів у пам'яті процесу.

**RAII-утиліти безпечного очищення (`secure_cleanup.h`).** Для усунення типових помилок ручного управління пам'яттю (патерн `goto cleanup`) розроблено набір RAII-утиліт:

- `ScopeGuard<F>` — шаблонний охоронець, що виконує довільну функцію очищення при виході зі scope. Підтримує `dismiss()` для скасування очищення при успішному завершенні. Некопійований, переміщуваний.

- `SecureLocal<N>` — шаблонний стековий буфер фіксованого розміру $N$ байт, що автоматично обнуляється через `sodium_memzero` як при конструюванні, так і при деструкції. Замінює патерн `uint8_t dh1[32] = {}; ...; cleanup: sodium_memzero(dh1, sizeof(dh1))` на `SecureLocal<32> dh1;` з гарантованим очищенням навіть при виключеннях або ранніх виходах.

- `OPAQUE_TRY(expr)` — макро для раннього повернення при невдачі. Замінює `result = op(); if (result != Success) goto cleanup;` на `OPAQUE_TRY(op());`, де cleanup виконується автоматично через деструктори `SecureLocal` та `ScopeGuard`.

- `secure_wipe(buffer)` та `secure_clear(buffer)` — утиліти для обнулення (зі збереженням ємності) та повного очищення (обнулення + звільнення) `secure_bytes`-буферів.

Ці утиліти забезпечують exception-safety та детерміноване очищення секретних даних без можливості пропуску через помилки у потоці управління. Деструктор `ResponderState`, наприклад, використовує `secure_wipe()` для статичних ключів та `secure_clear()` для сеансових секретів, гарантуючи повне очищення при будь-якому шляху завершення.

**Захист від атак за часом виконання.** Усі операції порівняння автентифікаційних тегів (MAC) виконуються за допомогою функції `crypto_verify_64()` бібліотеки libsodium, яка гарантує однаковий час виконання незалежно від позиції першого відмінного байта. Це запобігає атакам за часом (timing attacks), у яких зловмисник вимірює час відповіді сервера для поступового відновлення правильного MAC-тегу. Аналогічно, операції скалярного множення на Ristretto255 у libsodium реалізовані з використанням послідовностей інструкцій із постійним часом виконання, без умовних переходів, що залежать від значень секретних ключів.

**Валідація вхідних даних.** Кожне вхідне повідомлення проходить багаторівневу перевірку перед обробкою:
- перевірка довжини повідомлення на відповідність очікуваному розміру для даного типу (KE1, KE2, KE3) з урахуванням постквантових компонентів;
- перевірка приналежності отриманих точок до групи Ristretto255 за допомогою функції `crypto_core_ristretto255_is_valid_point()`, що запобігає атакам з використанням точок малого порядку або точок, що не належать кривій;
- перевірка ненульовості скалярних значень та публічних ключів;
- перевірка коректності шифротекстів ML-KEM за допомогою внутрішньої валідації liboqs.

У разі невдалої перевірки функція повертає помилку без виконання будь-яких криптографічних операцій, що запобігає оракульним атакам.

**Захист від витоків через логування.** Система діагностичного логування реалізована з чітким розділенням рівнів конфіденційності. У режимі відлагодження (`DEBUG`) логуються лише: ідентифікатори сесій, типи та розміри повідомлень, результати валідації (успіх/помилка), переходи між станами кінцевого автомата. Секретні ключі, проміжні значення OPRF, спільні секрети DH/KEM, паролі та їх похідні **ніколи** не потрапляють до журналу логів незалежно від рівня логування. Ця політика забезпечується архітектурно: функції логування не мають доступу до структур, що містять чутливі дані.

**Захист від помилок використання API.** Кінцевий автомат протоколу відхиляє повідомлення, отримані у некоректному стані. Наприклад, спроба надіслати KE3 до отримання KE2 призводить до помилки. Після завершення протоколу (стан `DONE`) повторне використання об'єкта сесії неможливе — потрібно створити новий екземпляр. Це виключає клас вразливостей, пов'язаних із повторним використанням ефемерних ключів або станів.


## 7. ОБГОВОРЕННЯ

У цьому розділі виконано систематичний аналіз відповідності запропонованого протоколу Hybrid PQ-OPAQUE встановленим вимогам, обговорено обмеження роботи та визначено напрямки подальших досліджень.

**Відповідність вимогам.** У таблиці 7.1 наведено зведену оцінку виконання кожної з п'яти вимог, сформульованих у розділі 3.

**Таблиця 7.1** — Відповідність протоколу Hybrid PQ-OPAQUE встановленим вимогам

| Вимога | Опис | Статус | Обґрунтування |
|:---|:---|:---:|:---|
| R1 | Збереження властивостей OPAQUE | Виконано | aPAKE, OPRF, KSF, структура конверта залишаються незмінними [6] |
| R2 | Постквантова стійкість обміну ключами | Виконано | ML-KEM-768 забезпечує IND-CCA2 безпеку на основі Module-LWE [15, 34] |
| R3 | Мінімальний overhead | Виконано | +2.3 КБ (+516%), 0 додаткових раундів, 1.5 RTT збережено |
| R4 | Гібридна безпека (AND-композиція) | Виконано | Комбінатор HKDF(K_dh ‖ K_kem) зберігає безпеку при компрометації одного примітиву |
| R5 | Сумісність з інфраструктурою | Виконано | C++23 бібліотека для 5 платформ із C/JNI/.NET/Swift інтерфейсами |

Як видно з таблиці 7.1, усі п'ять вимог виконано. Вимога R1 гарантована архітектурним принципом розширення: постквантовий компонент додається як паралельний канал виведення ключа без модифікації класичної логіки OPAQUE. Вимога R2 забезпечена інтеграцією ML-KEM-768, стандартизованого NIST у FIPS 203. Вимога R3 підтверджена кількісним аналізом у підрозділі 6.2. Вимога R4 реалізована через гібридний комбінатор на основі HKDF, що забезпечує AND-модель безпеки. Вимога R5 валідована практичною реалізацією з комплексним тестуванням.

**Обмеження роботи.** Незважаючи на досягнуті результати, слід чесно визнати ряд обмежень цього дослідження.

*Відповідність стандарту.* Запропонований протокол є «OPAQUE-подібним» (OPAQUE-like), але не є повністю конформним до чернетки IETF draft-irtf-cfrg-opaque [6]. Зокрема, формат серіалізації повідомлень, порядок полів та деталі виведення ключів можуть відрізнятися від специфікації IETF. Це означає, що реалізація не є взаємосумісною з іншими реалізаціями OPAQUE без додаткової адаптації. Обрана назва «OPAQUE-like» відображає цю ситуацію і є свідомим архітектурним рішенням, спрямованим на спрощення інтеграції постквантового компонента.

*Формальна верифікація: обсяг та обмеження.* Формальна верифікація протоколу виконана у символьній моделі Dolev--Yao за допомогою ProVerif 2.05, де всі 5 запитів безпеки (секретність сеансового ключа та паролю, двостороння відповідність, ін'єктивна взаємна автентифікація) підтверджені. Додатково побудовано модель у Tamarin Prover з 8 лемами безпеки. Проте символьна верифікація не охоплює обчислювальну модель: пряме доведення AND-моделі гібридної безпеки (теорема 4) потребує обчислювальної верифікації у CryptoVerif, що залишається напрямком подальшої роботи.

*Стійкість до атак побічними каналами.* Захист від атак за часом виконання, споживанням енергії та електромагнітним випромінюванням делегований бібліотекам libsodium та liboqs. Хоча обидві бібліотеки приділяють значну увагу стійкості до побічних каналів, вона не є формально доведеною для усіх підтримуваних платформ. Зокрема, реалізація ML-KEM у liboqs є еталонною (reference implementation) і може бути вразливою до мікроархітектурних атак на певних процесорних архітектурах.

*Відсутність детерміністичних тестових векторів.* На момент написання роботи не існує опублікованих тестових векторів для гібридного PQ-OPAQUE, що ускладнює незалежну валідацію коректності реалізації. Тестування здійснюється шляхом перевірки інваріантів протоколу (успішна автентифікація з правильним паролем, відмова з неправильним), а не шляхом порівняння проміжних значень із еталонними.

*Обмеження на довжину ключів.* Реалізація встановлює максимальну довжину безпечного ключа `MAX_SECURE_KEY_LENGTH = 4096` байт, що є достатнім для поточних параметрів ML-KEM-768 та Ristretto255, але може потребувати перегляду при переході до більших параметрів постквантових схем.

*Класичний OPRF.* OPRF-компонент протоколу реалізовано на групі Ristretto255 і не є постквантово стійким (підрозд. 5.2.8). Хоча Argon2id суттєво ускладнює експлуатацію цього вектора, повна постквантова стійкість потребуватиме міграції OPRF на постквантовий примітив.

**Алгоритмічна гнучкість (Algorithm Agility).** Конструкція Hybrid PQ-OPAQUE спроектована з урахуванням можливості заміни постквантового компонента. Завдяки модульній архітектурі з чітким розділенням KEM-інтерфейсу (`KeyGen`, `Encaps`, `Decaps`) та гібридного комбінатора HKDF, заміна ML-KEM-768 на інший KEM (наприклад, ML-KEM-1024 для вищого рівня безпеки, ML-KEM-512 для IoT, або майбутні стандарти NIST PQC Round 4) потребує лише зміни параметрів `KEM_PUBLIC_KEY_LENGTH`, `KEM_CIPHERTEXT_LENGTH`, `KEM_SECRET_KEY_LENGTH` та підключення відповідної бібліотечної реалізації. Решта протоколу — OPRF, конверт, 3-DH, транскрипт, MAC — залишаються незмінними. Доменні розділювачі з префіксом `ECLIPTIX-OPAQUE-PQ-v1/` забезпечують версіювання, що дозволяє безпечно мігрувати між наборами параметрів.

**Порівняння з KHAPE.** Кравчик запропонував KHAPE (Key-Hiding Augmented PAKE) [31] як вдосконалення OPAQUE з властивістю приховання ключа (key-hiding): навіть при компрометації серверної бази даних та паролю, статичні ключі клієнта залишаються прихованими. Hybrid PQ-OPAQUE базується на класичній конструкції OPAQUE з 3-DH, а не на KHAPE, оскільки: (1) специфікація IETF CFRG [6] стандартизує саме OPAQUE з 3-DH; (2) гібридна постквантова конструкція є ортогональним розширенням і може бути застосована як до OPAQUE, так і до KHAPE; (3) KHAPE потребує додаткових досліджень щодо формальної верифікації в контексті постквантових компонентів. Побудова Hybrid PQ-KHAPE є перспективним напрямком подальшої роботи.

**Напрямки подальших досліджень.** На основі виявлених обмежень визначено наступні пріоритетні напрямки подальшої роботи.

*Обчислювальна формальна верифікація.* Виконана символьна верифікація у ProVerif (5/5 запитів підтверджено) та побудована модель у Tamarin Prover (8 лем) забезпечують сильні гарантії у моделі Dolev--Yao. Наступним кроком є верифікація AND-моделі гібридної безпеки (теорема 4) в обчислювальній моделі за допомогою CryptoVerif, що дозволить формалізувати аргумент про нерозрізнимість PRK від випадкового за умови стійкості хоча б одного з криптографічних примітивів.

*Постквантові цифрові підписи.* Поточна конструкція використовує MAC-автентифікацію на основі HMAC для підтвердження сесії (повідомлення KE3). Перспективним напрямком є дослідження заміни MAC на цифрові підписи ML-DSA (FIPS 204) [16], що дозволить забезпечити властивість неспростовності (non-repudiation) автентифікації. Проте це значно збільшить розмір повідомлень через великий розмір підписів ML-DSA (2420–4627 байт).

*Оптимізація для пристроїв з обмеженими ресурсами.* Для сценаріїв Інтернету речей (IoT) доцільно дослідити використання ML-KEM-512 замість ML-KEM-768, що зменшить постквантові витрати приблизно на 30% за рахунок зниження рівня безпеки зі 192 до 128 біт. Для контексту IoT це може бути прийнятним компромісом.

*Стандартизація.* Подання пропозиції щодо постквантового розширення OPAQUE до робочої групи IETF CFRG є важливим кроком для забезпечення широкого впровадження. Стандартизований PQ-OPAQUE міг би стати частиною екосистеми TLS 1.3 для автентифікації за паролем із постквантовим захистом.


## 8. ВИСНОВКИ

У даній роботі вирішено актуальну наукову задачу забезпечення постквантової стійкості протоколу автентифікації за паролем з асиметричним обміном ключами OPAQUE. Актуальність задачі обумовлена прогнозованою появою криптографічно значущих квантових комп'ютерів, здатних зламати класичні криптосистеми на основі задачі дискретного логарифмування (зокрема, протокол Діффі — Геллмана на еліптичних кривих), які є основою обміну ключами в класичному OPAQUE.

Наукова новизна роботи полягає в розробці гібридної конструкції PQ-OPAQUE, що поєднує класичний обмін ключами на основі протоколу 3DH (три операції Діффі — Геллмана на кривій Ristretto255) з постквантовим механізмом інкапсуляції ключів ML-KEM-768 (NIST FIPS 203) через гібридний комбінатор на основі HKDF. На відміну від існуючих підходів до постквантової міграції протоколів (TLS [18], Signal [19], WireGuard [20]), що замінюють або доповнюють протокол Діффі — Геллмана в контексті традиційного обміну ключами, запропонована конструкція вперше вирішує задачу для протоколу aPAKE-класу, зберігаючи при цьому всі унікальні властивості OPAQUE: забудькувату псевдовипадкову функцію для захисту паролів, ключову функцію розтягування для протидії перебору та криптографічний конверт для зберігання автентифікаційних даних.

Основні результати роботи:

1. **Розроблено гібридний комбінатор сесійних ключів**, що реалізує AND-модель безпеки: сесійний ключ залишається захищеним за умови стійкості хоча б одного з двох компонентів (класичного DH або постквантового KEM). Комбінатор побудований на основі HKDF-Extract із конкатенацією спільних секретів як вхідного ключового матеріалу, що забезпечує рівномірний розподіл вихідного ключа незалежно від статистичних властивостей окремих компонентів.

2. **Доведено збереження всіх класичних властивостей OPAQUE** у гібридній конструкції: стійкість до попередніх обчислень (pre-computation resistance) через OPRF, захист від офлайн-перебору паролів через Argon2id, відсутність еквівалентів паролів у відкритому вигляді (asymmetric PAKE), стійкість до компрометації сервера. Реєстраційний запис на сервері має ідентичний формат у класичному та гібридному варіантах, що спрощує міграцію.

3. **Виконано формальну верифікацію протоколу** у системі автоматичного доведення ProVerif 2.05: усі 5 запитів безпеки підтверджені (секретність сеансового ключа та паролю за умови компрометації довготривалого ключа сервера, двостороння відповідність клієнт↔сервер, ін'єктивна взаємна автентифікація зі стійкістю до replay-атак). Побудовано символьну модель у Tamarin Prover з 8 лемами безпеки (session\_key\_secrecy, password\_secrecy, forward\_secrecy\_classical, pq\_forward\_secrecy, mutual\_authentication у обох напрямках, and\_model\_security, offline\_dictionary\_resistance). Формальна верифікація виключає широкий клас логічних помилок у конструкції протоколу, що не завжди виявляються редукційними аргументами.

4. **Кількісно оцінено накладні витрати гібридизації**: додаткові 2272 байт (+516%) до сумарного обсягу обміну при нульовому збільшенні кількості раундів (1.5 RTT). Експериментальна оцінка на Apple M1 Pro показала: повний раунд ML-KEM-768 (55.3 + 67.2 = 122.5 мкс) є порівнянним з трьома операціями Ristretto255 DH (~131 мкс); гібридний комбінатор HKDF додає лише 5.8 мкс; загальна латентність автентифікації складає 586 мс, з яких 99.8% припадає на Argon2id; серверна пропускна здатність — ~3010 операцій KE2 на секунду (одне ядро).

5. **Створено крос-платформну бібліотеку** мовою C++23 з підтримкою п'яти цільових платформ (macOS, Linux, Windows, iOS, Android), чотирьох інтерфейсів інтероперабельності (C API, JNI, .NET, Swift), RAII-утилітами безпечного очищення пам'яті (`ScopeGuard`, `SecureLocal<N>`, `OPAQUE_TRY`), `SecureAllocator<T>` з `mlock()` та `sodium_memzero()`, постійним часом виконання порівнянь MAC та багаторівневою валідацією вхідних даних.

Практичне значення отриманих результатів полягає у забезпеченні шляху поступової міграції систем автентифікації за паролем до постквантової безпеки. Гібридний підхід дозволяє розпочати впровадження постквантового захисту вже сьогодні, не втрачаючи класичної безпеки у разі виявлення вразливостей у нових постквантових схемах. Прийнятний рівень накладних витрат (2.3 КБ на автентифікацію, ~0.12 мс додаткових обчислень для ML-KEM) та відсутність додаткових раундів обміну роблять протокол придатним для промислового застосування у системах, де автентифікація за паролем є основним механізмом доступу.


## СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

[1] Bonneau J., Herley C., van Oorschot P. C., Stajano F. The quest to replace passwords: A framework for comparative evaluation of web authentication schemes // Proc. IEEE Symposium on Security and Privacy (S&P). — San Francisco, CA, USA, 2012. — P. 553–567.

[2] Florencio D., Herley C. A large-scale study of web password habits // Proc. 16th International Conference on World Wide Web (WWW). — Banff, AB, Canada, 2007. — P. 657–666.

[3] Bellare M., Pointcheval D., Rogaway P. Authenticated key exchange secure against dictionary attacks // Advances in Cryptology — EUROCRYPT 2000, Lecture Notes in Computer Science, vol. 1807. — Springer, 2000. — P. 139–155.

[4] Jarecki S., Krawczyk H., Xu J. OPAQUE: An asymmetric PAKE protocol secure against pre-computation attacks // Advances in Cryptology — EUROCRYPT 2018, Lecture Notes in Computer Science, vol. 10822. — Springer, 2018. — P. 456–486.

[5] Freedman M. J., Ishai Y., Pinkas B., Reingold O. Keyword search and oblivious pseudorandom functions // Theory of Cryptography Conference (TCC 2005), Lecture Notes in Computer Science, vol. 3378. — Springer, 2005. — P. 303–324.

[6] Bourdrez D., Krawczyk H., Lewi K., Wood C. A. The OPAQUE asymmetric PAKE protocol // Internet Engineering Task Force (IETF), Internet-Draft draft-irtf-cfrg-opaque. — 2024. — URL: https://datatracker.ietf.org/doc/draft-irtf-cfrg-opaque/.

[7] Wu T. The Secure Remote Password protocol // Proc. Internet Society Network and Distributed System Security Symposium (NDSS). — San Diego, CA, USA, 1998. — P. 97–111.

[8] Abdalla M., Pointcheval D. Simple password-based encrypted key exchange protocols // Topics in Cryptology — CT-RSA 2005, Lecture Notes in Computer Science, vol. 3376. — Springer, 2005. — P. 191–208.

[9] Shor P. W. Algorithms for quantum computation: Discrete logarithms and factoring // Proc. 35th Annual Symposium on Foundations of Computer Science (FOCS). — Santa Fe, NM, USA, 1994. — P. 124–134.

[10] Bernstein D. J., Lange T. Post-quantum cryptography // Nature. — 2017. — Vol. 549, No. 7671. — P. 188–194.

[11] Roetteler M., Naehrig M., Svore K. M., Lauter K. Quantum resource estimates for computing elliptic curve discrete logarithms // Advances in Cryptology — ASIACRYPT 2017, Lecture Notes in Computer Science, vol. 10625. — Springer, 2017. — P. 241–270.

[12] National Academies of Sciences, Engineering, and Medicine. Quantum computing: Progress and prospects. — Washington, DC : The National Academies Press, 2019. — 273 p.

[13] Mosca M. Cybersecurity in an era with quantum computers: Will we be ready? // IEEE Security & Privacy. — 2018. — Vol. 16, No. 5. — P. 38–41.

[14] National Institute of Standards and Technology (NIST). Post-quantum cryptography: Call for proposals // Federal Register. — 2016. — URL: https://csrc.nist.gov/projects/post-quantum-cryptography.

[15] National Institute of Standards and Technology (NIST). Module-Lattice-Based Key-Encapsulation Mechanism Standard: FIPS 203. — Gaithersburg, MD, USA, 2024. — 39 p.

[16] National Institute of Standards and Technology (NIST). Module-Lattice-Based Digital Signature Standard: FIPS 204. — Gaithersburg, MD, USA, 2024. — 40 p.

[17] Avanzi R., Bos J., Ducas L., Kiltz E., Lepoint T., Lyubashevsky V., Schanck J. M., Schwabe P., Seiler G., Stehlé D. CRYSTALS-Kyber: Algorithm specifications and supporting documentation (version 3.02) // NIST Post-Quantum Cryptography Standardization, Round 3 Submission. — 2022. — 43 p.

[18] Stebila D., Fluhrer S., Gueron S. Hybrid key exchange in TLS 1.3 // Internet Engineering Task Force (IETF), Internet-Draft draft-ietf-tls-hybrid-design. — 2024. — URL: https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design/.

[19] Brendel J., Fiedler R., Günther F., Jacobsen C., Poettering B. Post-quantum security of the Signal protocol // Selected Areas in Cryptography (SAC 2020), Lecture Notes in Computer Science, vol. 12804. — Springer, 2020. — P. 567–591.

[20] Hülsing A., Ning K.-C., Schwabe P., Weber F., Zimmermann P. R. Post-quantum WireGuard // Proc. IEEE Symposium on Security and Privacy (S&P). — San Francisco, CA, USA, 2021. — P. 304–321.

[21] Bindel N., Hamburg M., Hövelmanns K., Hülsing A., Persichetti E. Tighter proofs of CCA security in the quantum random oracle model // Post-Quantum Cryptography (PQCrypto 2019), Lecture Notes in Computer Science, vol. 11505. — Springer, 2019. — P. 61–79.

[22] Canetti R. Universally composable security: A new paradigm for cryptographic protocols // Proc. 42nd Annual Symposium on Foundations of Computer Science (FOCS). — Las Vegas, NV, USA, 2001. — P. 136–145.

[23] Katz J., Vaikuntanathan V. Smooth projective hashing and password-based authenticated key exchange from lattices // Advances in Cryptology — ASIACRYPT 2009, Lecture Notes in Computer Science, vol. 5912. — Springer, 2009. — P. 636–652.

[24] Boyko V., MacKenzie P., Patel S. Provably secure password-authenticated key exchange using Diffie-Hellman // Advances in Cryptology — EUROCRYPT 2000, Lecture Notes in Computer Science, vol. 1807. — Springer, 2000. — P. 156–171.

[25] Bellovin S. M., Merritt M. Encrypted key exchange: Password-based protocols secure against dictionary attacks // Proc. IEEE Symposium on Security and Privacy (S&P). — Oakland, CA, USA, 1992. — P. 72–84.

[26] Haase B., Labrique B. AuCPace: Efficient verifier-based PAKE protocol tailored for the IIoT // IACR Transactions on Cryptographic Hardware and Embedded Systems (TCHES). — 2019. — Vol. 2019, No. 2. — P. 1–48.

[27] Ladd W., Kaduk B., Harkins D. SPAKE2, a PAKE // Internet Engineering Task Force (IETF), RFC 9382. — 2023. — URL: https://www.rfc-editor.org/rfc/rfc9382.

[28] Haase B., Labrique B. CPace, a balanced composable PAKE // Internet Engineering Task Force (IETF), Internet-Draft draft-irtf-cfrg-cpace. — 2024. — URL: https://datatracker.ietf.org/doc/draft-irtf-cfrg-cpace/.

[29] de Valence H., Grigg J., Hamburg M., Lovecruft I., Tankersley G., Valsorda F. The ristretto255 and decaf448 groups // Internet Engineering Task Force (IETF), Internet-Draft draft-irtf-cfrg-ristretto255-decaf448. — 2024. — URL: https://datatracker.ietf.org/doc/draft-irtf-cfrg-ristretto255-decaf448/.

[30] Biryukov A., Dinu D., Khovratovich D. Argon2: New generation of memory-hard functions for password hashing and other applications // Proc. IEEE European Symposium on Security and Privacy (Euro S&P). — Saarbrücken, Germany, 2016. — P. 292–302.

[31] Krawczyk H. The OPAQUE asymmetric PAKE protocol // Advances in Cryptology — CRYPTO 2021, Lecture Notes in Computer Science, vol. 12828. — Springer, 2021. — P. 1–28.

[32] Krawczyk H. HMQV: A high-performance secure Diffie-Hellman protocol // Advances in Cryptology — CRYPTO 2005, Lecture Notes in Computer Science, vol. 3621. — Springer, 2005. — P. 546–566.

[33] Krawczyk H., Eronen P. HMAC-based Extract-and-Expand Key Derivation Function (HKDF) // Internet Engineering Task Force (IETF), RFC 5869. — 2010. — URL: https://www.rfc-editor.org/rfc/rfc5869.

[34] Regev O. On lattices, learning with errors, random linear codes, and cryptography // Journal of the ACM. — 2009. — Vol. 56, No. 6. — Article 34. — P. 1–40.

[35] Denis F. libsodium: A modern, portable, easy to use crypto library. — URL: https://doc.libsodium.org/; Open Quantum Safe Project. liboqs: An open-source C library for quantum-safe cryptographic algorithms. — URL: https://openquantumsafe.org/.

[36] Blanchet B. An efficient cryptographic protocol verifier based on Prolog rules // Proc. 14th IEEE Computer Security Foundations Workshop (CSFW). — Cape Breton, NS, Canada, 2001. — P. 82–96.

[37] Dolev D., Yao A. C. On the security of public key protocols // IEEE Transactions on Information Theory. — 1983. — Vol. 29, No. 2. — P. 198–208.

[38] Bhargavan K., Blanchet B., Kobeissi N. Verified models and reference implementations for the TLS 1.3 standard candidate // Proc. IEEE Symposium on Security and Privacy (S&P). — San Jose, CA, USA, 2017. — P. 483–502.

[39] Schmidt B., Meier S., Cremers C., Basin D. Automated analysis of Diffie-Hellman protocols and advanced security properties // Proc. 25th IEEE Computer Security Foundations Symposium (CSF). — Cambridge, MA, USA, 2012. — P. 78–94.

[40] Blanchet B. A computationally sound mechanized prover for security protocols // IEEE Transactions on Dependable and Secure Computing. — 2008. — Vol. 5, No. 4. — P. 193–207.

[41] Krawczyk H. Cryptographic extraction and key derivation: The HKDF scheme // Advances in Cryptology — CRYPTO 2010, Lecture Notes in Computer Science, vol. 6223. — Springer, 2010. — P. 631–648.

[42] Giacon F., Heuer F., Poettering B. KEM combiners // Proc. IACR International Conference on Public-Key Cryptography (PKC 2018), Lecture Notes in Computer Science, vol. 10769. — Springer, 2018. — P. 190–218.