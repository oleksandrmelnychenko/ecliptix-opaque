# Гібридний постквантовий протокол автентифікації на основі парольного ключового обміну OPAQUE з інтеграцією ML-KEM-768: розробка, формальна верифікація та реалізація

---

## АНОТАЦІЯ

Парольна автентифікація залишається домінуючим механізмом підтвердження особи користувачів у сучасних інформаційних системах. Криптографічну основу найбільш захищених протоколів парольного автентифікованого ключового обміну (PAKE), зокрема протоколу OPAQUE, складають операції на еліптичних кривих та протокол Діффі--Геллмана, безпека яких ґрунтується на обчислювальній складності задачі дискретного логарифмування. Поява масштабованих квантових обчислювальних пристроїв, здатних ефективно реалізувати алгоритм Шора за поліноміальний час, створює фундаментальну загрозу для зазначених криптографічних примітивів. Стратегія «збирай зараз — дешифруй пізніше» робить цю загрозу практично значущою вже на теперішній момент.

Метою цього дослідження є розробка, формальна верифікація та реалізація гібридного постквантового розширення протоколу OPAQUE, що забезпечує одночасну стійкість як до класичних, так і до квантових криптоаналітичних атак. Запропоновано конструкцію Гібридного PQ-OPAQUE, в якій механізм інкапсуляції ключів ML-KEM-768 (FIPS 203) інтегровано в потік автентифікованого ключового обміну за схемою 4DH як обов'язкову складову протоколу, а не факультативне розширення. Класичний ключовий матеріал від чотирьох операцій Діффі--Геллмана на кривій Ristretto255 (128 байт) конкатенується зі спільним секретом ML-KEM-768 (32 байти); об'єднаний вхід обсягом 160 байт опрацьовується функцією HKDF-Extract на основі HMAC-SHA-512 із контекстно-залежною сіллю, що містить мічений геш розширеного транскрипту.

Безпеку протоколу верифіковано двома незалежними інструментами символьної верифікації: **ProVerif 2.05** (підтверджено 5 з 5 запитів) та **Tamarin Prover 1.10.0** (доведено 8 з 8 лем за 28,08 с). Реалізацію виконано мовою програмування **Rust 1.93.1** у вигляді багатокрейтного простору проєктів із чотирьох крейтів загальним обсягом 3\,749 рядків виробничого коду та 2\,731 рядків тестів. Комплексний набір тестів включає **126 тестових сценаріїв** (0 відмов), що охоплюють сім властивостей безпеки. Вимірювання продуктивності на платформі Apple M1 Pro засвідчили: повний цикл автентифікації (наскрізний) --- 481,43 мс; операції ML-KEM-768 (генерація ключів + інкапсуляція + декапсуляція) --- 122,01 мкс; чотиристороннє перетворення Діффі--Геллмана (4 скалярних множення) --- $\approx 164$ мкс; функція $\texttt{generate\_ke2}$ --- 297,03 мкс. Домінування функції жорсткого перетворення пароля Argon2id (510,86 мс, 99,8\% часу наскрізного виконання) підтверджує відповідність дизайну вимогам стійкості до атак офлайн-перебирання.

**Ключові слова:** OPAQUE, парольний автентифікований ключовий обмін (PAKE), ML-KEM-768, постквантова криптографія, гібридний ключовий обмін, Ristretto255, HKDF, формальна верифікація, Tamarin, ProVerif, Rust.

---

## 1. ВСТУП

### 1.1. Актуальність проблеми

Парольна автентифікація залишається найбільш поширеним механізмом підтвердження особи в сучасних розподілених інформаційних системах. За різними оцінками, понад 80% процедур автентифікації у веб-додатках та мережевих сервісах базуються на паролях [1, 2]. Незважаючи на розвиток альтернативних методів (апаратні ключі, біометрія, passkeys), паролі залишаються домінуючим чинником автентифікації внаслідок універсальної сумісності, відсутності потреби у спеціалізованому обладнанні та звичності для кінцевих користувачів.

Протоколи парольного автентифікованого ключового обміну (Password-Authenticated Key Exchange, PAKE) забезпечують встановлення захищеного каналу зв'язку між двома сторонами, що поділяють спільний секрет низької ентропії -- пароль -- без розкриття цього паролю противнику [3]. На відміну від стандартних схем парольної автентифікації (передача гешу пароля по TLS), PAKE-протоколи *математично гарантують*, що пароль ніколи не залишає пристрій клієнта навіть у зашифрованому вигляді: обмін ключами базується на алгебраїчних операціях, вхідні дані яких не містять прямого представлення пароля.

Серед відомих протоколів PAKE протокол OPAQUE, запропонований Jarecki, Krawczyk та Xu у 2018 році [4], вважається найбільш безпечним представником класу асиметричних (augmented) PAKE: сервер зберігає лише криптографічний запис, з якого неможливо відновити пароль навіть при повній компрометації серверного сховища [6].

### 1.2. Квантова загроза

У 1994 році Пітер Шор запропонував квантовий алгоритм [9], здатний розв'язувати задачу дискретного логарифмування за поліноміальний час на квантовому комп'ютері. Цей алгоритм безпосередньо загрожує всім криптосистемам на основі DLP та ECDLP: RSA, ECDH, а також будь-якому PAKE-протоколу, що будується на їх основі [10]. За оцінками, для зламу Ristretto255/Curve25519 (128-бітний рівень класичної безпеки) достатньо криптографічно значущого квантового комп'ютера з приблизно 2\,330 логічними кубітами [11]. Хоча сучасні квантові обчислювальні пристрої ще не досягли необхідного масштабу, темпи розвитку галузі та значні державні інвестиції (США, ЄС, Китай) свідчать про реальну перспективу появи таких систем протягом найближчих 10–20 років [12].

Особливу небезпеку становить стратегія «збирай зараз --- дешифруй пізніше» (store-now-decrypt-later, SNDL) [13]: противник зберігає зашифрований трафік сьогодні з метою ретроспективного криптоаналізу на квантовому комп'ютері в майбутньому. Для систем, що опрацьовують довготривалі конфіденційні дані (медичні записи, фінансові транзакції, військові комунікації), ця загроза є практично значущою вже на теперішній момент: дані, зашифровані сьогодні, можуть бути розшифровані через 10--15 років, коли вони все ще зберігатимуть конфіденційну цінність.

У контексті протоколів PAKE стратегія SNDL є особливо небезпечною: перехоплений трафік автентифікації містить зашифрований конверт з довготривалими обліковими даними (приватні ключі, зашифрований парольний матеріал). Відновлення ключового матеріалу DH (через квантовий алгоритм) дозволить *деривувати всі сесійні ключі*, що відповідає повній компрометації всіх минулих та поточних сесій користувача.

### 1.3. Стандартизація постквантової криптографії

У серпні 2024 року NIST опублікував перші стандарти постквантової криптографії: FIPS 203 (ML-KEM) [15] та FIPS 204 (ML-DSA) [16]. Ці стандарти є результатом семирічного конкурсу (2017--2024) з 69 початкових кандидатів та трьох раундів оцінювання, що включали як теоретичний криптоаналіз, так і аналіз ефективності реалізацій на різних платформах [14, 17]. ML-KEM базується на задачі навчання з помилками на модульних решітках (Module-LWE), для якої не відомо ефективних квантових алгоритмів: найкращі відомі квантові атаки забезпечують лише квадратичне прискорення (алгоритм Гровера) порівняно з класичними решіткоредукційними методами (BKZ). Паралельно гібридні підходи (класика + PQ) впроваджуються в TLS 1.3 [18], Signal (PQXDH) [19] та WireGuard [20].

### 1.4. Обмеження існуючих рішень

Класичний OPAQUE у поточній специфікації IETF [6] не містить механізмів захисту від квантових атак: ключовий матеріал 3DH може бути відновлений алгоритмом Шора. Конкретно, квантовий противник, маючи перехоплений трафік сесії, може відновити $sk_C$ та $sk_S$ з відповідних відкритих ключів, обчислити всі три (або чотири) добутки DH, деривувати PRK та відновити сесійний ключ $K_s$, що є повною компрометацією. Інші PAKE-протоколи (SRP, SPAKE2) є так само вразливими, оскільки їх безпека ґрунтується виключно на складності DLP/ECDLP.

Чисто постквантові PAKE перебувають на ранній стадії дослідження та не досягли рівня зрілості, придатного для виробничого застосування [23]. Основні перешкоди: (а) відсутність ефективних решіткових OPRF-конструкцій; (б) суттєво більші розміри повідомлень ($\times 5$--$10$ порівняно з OPAQUE); (в) відсутність доведень безпеки в моделі UC для повних конструкцій.

Існуючі гібридні рішення (TLS 1.3, Signal, WireGuard) не адресують парольну автентифікацію: вони не використовують OPRF та не реалізують модель aPAKE. У відкритій науковій літературі відсутні стандартизовані гібридні постквантові розширення OPAQUE.

### 1.5. Мета та завдання дослідження

**Мета:** розробка, формальна верифікація та реалізація гібридного постквантового протоколу на основі OPAQUE, що забезпечує одночасну стійкість до класичних та квантових атак без втрати фундаментальних властивостей безпеки aPAKE.

**Завдання:**
1. Розробити конструкцію гібридного комбінатора ключового матеріалу (4DH + ML-KEM-768);
2. Специфікувати розширений транскрипт із постквантовими елементами;
3. Провести формальну верифікацію (ProVerif + Tamarin) семи властивостей безпеки;
4. Реалізувати протокол мовою Rust та виміряти продуктивність за допомогою статистичних еталонних вимірювань Criterion;
5. Оцінити прийнятність накладних витрат для практичного застосування.

### 1.6. Наукова новизна та внесок

1. **Гібридна конструкція PQ-OPAQUE.** Вперше запропоновано та реалізовано гібридну схему розширення OPAQUE, в якій ML-KEM-768 є *обов'язковою* складовою протоколу, а не факультативним розширенням.
2. **Спеціалізований комбінатор ключового матеріалу.** $\text{PRK} = \text{HKDF-Extract}(\text{salt}_\tau,\; dh_1 \| dh_2 \| dh_3 \| dh_4 \| ss_{\text{kem}})$ із контекстно-залежною сіллю, що містить мічений геш розширеного транскрипту $\tau$.
3. **Розширений транскрипт із постквантовими елементами.** Включення $pk_{\text{kem}}$ (1184 байти) та $ct_{\text{kem}}$ (1088 байт) у транскрипт запобігає атакам зниження рівня безпеки.
4. **Повна формальна верифікація.** Сім властивостей безпеки верифіковано двома незалежними інструментами: ProVerif 2.05 (5/5) та Tamarin 1.10.0 (8 з 8 лем, 28,08 с).
5. **Реалізація мовою Rust із задокументованою продуктивністю.** Відкрита реалізація у вигляді чотирикрейтного простору проєктів, 126 тестових сценаріїв (0 відмов), статистичні еталонні вимірювання Criterion на платформі Apple M1 Pro.

### 1.7. Структура статті

Розділ 2 --- аналіз літературних джерел (PAKE, постквантова криптографія, сучасні PQ-PAKE підходи). Розділ 3 --- постановка задачі та модель загроз. Розділ 4 --- специфікація протоколу Гібридного PQ-OPAQUE. Розділ 5 --- аналіз безпеки (включаючи результати формальної верифікації). Розділ 6 --- реалізація та експериментальна оцінка продуктивності. Розділ 7 --- обговорення. Розділ 8 --- висновки.

---

## 2. АНАЛІЗ ЛІТЕРАТУРНИХ ДЖЕРЕЛ ТА ІСНУЮЧИХ РІШЕНЬ

### 2.1 Протоколи парольного автентифікованого ключового обміну (PAKE)

Парольний автентифікований ключовий обмін (PAKE) --- клас протоколів, які дозволяють двом сторонам, що поділяють спільний секрет низької ентропії (пароль), встановити автентифікований сесійний ключ, стійкий до офлайн-атак за словником [24]. Протоколи PAKE поділяються на дві категорії:

- *Збалансовані (balanced) PAKE* --- обидві сторони зберігають ідентичне парольне представлення. Приклади: EKE [26], SPAKE2 [27], CPace [28].
- *Асиметричні (augmented) PAKE, або aPAKE* --- сервер зберігає лише парольний верифікатор. Приклади: SRP [29], AuCPace [30], OPAQUE [4].

**Таблиця 1 -- Порівняльна характеристика протоколів PAKE**

| Властивість | EKE [26] | SRP [29] | SPAKE2 [27] | OPAQUE [4] |
|---|---|---|---|---|
| Тип | Balanced | Augmented | Balanced | Augmented |
| Приховування пароля від сервера | Ні | Частково | Ні | Так (OPRF) |
| Стійкість до попередньо обчислених атак | Ні | Ні | Ні | Так |
| Пряма секретність | Так | Так | Так | Так |
| Стійкість до компрометації сервера | Ні | Часткова | Ні | Так |
| Формальне доведення безпеки | IC model | Відсутнє | ROM | UC model |
| Стійкість до квантових атак | Ні | Ні | Ні | Ні |

Як видно з Таблиці 1, OPAQUE є єдиним протоколом, що забезпечує *одночасно* приховування пароля від сервера, стійкість до попередньо обчислених атак та формальне доведення в моделі UC. Саме ці властивості роблять OPAQUE оптимальним кандидатом для постквантового розширення: гібридний PQ-компонент додає квантову стійкість, зберігаючи всі інші переваги. Протоколи SRP та SPAKE2, незважаючи на широке впровадження, не забезпечують приховування пароля від сервера та не мають формальних доведень безпеки (SRP) або мають доведення лише в моделі випадкового оракула (SPAKE2).

### 2.2 Протокол OPAQUE: формальний опис

Протокол OPAQUE [4] складається з фази реєстрації та фази автентифікації, обидві спираються на механізм забутливої псевдовипадкової функції (OPRF). Ключовий обмін виконує три або чотири операції скалярного множення (3DH у специфікації IETF [6]; четверту операцію $dh_4 = e_S \cdot E_C$ для стійкості до атаки невідомого ключового обміну (UKS) додано у цій роботі): $dh_1 = sk_S \cdot PK_C$ (взаємна автентифікація), $dh_2 = sk_S \cdot E_C$, $dh_3 = e_S \cdot PK_C$ (пряма секретність), $dh_4 = e_S \cdot E_C$ (UKS-стійкість). Безпека доведена в моделі Universal Composability (UC) [22] --- найсильнішій з відомих моделей для PAKE. Специфікація IETF [6] не містить постквантових компонентів.

**Механізм конверта (envelope).** Ключовою інновацією OPAQUE є те, що сервер зберігає не пароль і не його геш, а *зашифрований конверт*, що містить приватний ключ клієнта $sk_C$. Конверт запечатується ключем, деривованим з виходу OPRF та пароля: $K_{\text{env}} = \text{KDF}(\text{rwd}, \text{context})$, де $\text{rwd}$ --- рандомізований пароль, отриманий через функцію жорсткого перетворення (Argon2id). Компрометація серверного сховища розкриває лише зашифрований конверт; без пароля противник не може обчислити $\text{rwd}$ і, відповідно, не може відкрити конверт. Ця архітектура забезпечує *офлайн-стійкість*: перевірка кожного кандидата пароля вимагає взаємодії з OPRF-оракулом сервера.

**Забутлива псевдовипадкова функція (OPRF).** Забутлива псевдовипадкова функція забезпечує дві ключові властивості: (1) *засліпленість* --- сторона-обчислювач не отримує жодної інформації про вхідне значення $x$ клієнта; (2) *псевдовипадковість* --- вихід $F_k(x)$ обчислювально нерозрізнений від рівномірного випадкового. Реалізація використовує геш на групу Ristretto255 [34]:
$$\alpha = r \cdot H'(\text{ctx} \| x),\quad \beta = k \cdot \alpha,\quad F_k(x) = r^{-1} \cdot \beta,$$
де $r \xleftarrow{\$} \mathbb{Z}_q^*$ --- засліплюючий скаляр клієнта, $k$ --- секретний ключ сервера. Засліпленість забезпечується тим, що сервер обчислює $\beta = k \cdot \alpha = k \cdot r \cdot H'(x)$, не знаючи ні $r$, ні $x$ окремо. Після отримання $\beta$ клієнт обчислює $F_k(x) = r^{-1} \cdot \beta = k \cdot H'(x)$ --- детерміністичний результат, що залежить лише від серверного ключа $k$ та входу $x$.

### 2.3 Постквантова криптографія та стандарти NIST 2024

Алгоритм Шора [9] розв'язує DLP та ECDLP за поліноміальний час, роблячи небезпечними RSA, ECDH та всі PAKE-протоколи на їх основі. Стратегія «збирай зараз --- дешифруй пізніше» [13] актуалізує цю загрозу вже сьогодні, задовго до практичного введення квантових обчислювальних засобів в експлуатацію.

**Хронологія стандартизації NIST PQC.** Процес стандартизації постквантової криптографії NIST розпочався у 2016 році з відкритого конкурсу [14]. Після трьох раундів оцінювання (2017--2022), у серпні 2024 року опубліковано перші стандарти: FIPS 203 (ML-KEM, механізм інкапсуляції ключів на основі модульних решіток) [15], FIPS 204 (ML-DSA, цифровий підпис на основі модульних решіток) [16] та FIPS 205 (SLH-DSA, безстановий цифровий підпис на основі геш-функцій). ML-KEM є вдосконаленою версією CRYSTALS-Kyber [17], що пройшла криптоаналіз протягом 7 років конкурсу.

**ML-KEM-768.** Обрано набір параметрів рівня безпеки NIST Level 3 (еквівалент AES-192). ML-KEM-768 базується на задачі навчання з помилками на модульних решітках (Module Learning With Errors, MLWE) з параметром модуля $k = 3$. Параметри: $|pk| = 1184$ байт, $|ct| = 1088$ байт, $|ss| = 32$ байт, $|sk| = 2400$ байт, безпека IND-CCA2. Конструкція: $\text{KeyGen}() \to (pk, sk)$; $\text{Encaps}(pk) \to (ct, ss)$; $\text{Decaps}(sk, ct) \to ss$ [15]. Ймовірність відмови декапсуляції (некоректне відновлення спільного секрету) дорівнює $\delta \leq 2^{-164}$, що є нехтовно малою величиною.

**Таблиця 2.2 --- Порівняння рівнів безпеки ML-KEM**

| Набір параметрів | Рівень NIST | $|pk|$ | $|ct|$ | $|sk|$ | $|ss|$ | Модуль $k$ |
|---|---|---|---|---|---|---|
| ML-KEM-512 | 1 (AES-128) | 800 б | 768 б | 1632 б | 32 б | 2 |
| **ML-KEM-768** | **3 (AES-192)** | **1184 б** | **1088 б** | **2400 б** | **32 б** | **3** |
| ML-KEM-1024 | 5 (AES-256) | 1568 б | 1568 б | 3168 б | 32 б | 4 |

Вибір ML-KEM-768 обумовлений балансом між рівнем безпеки та обсягом накладних витрат: ML-KEM-512 забезпечує лише рівень 1 (недостатній для довготривалих конфіденційних даних), тоді як ML-KEM-1024 збільшує обсяг повідомлень на $\approx 30\%$ порівняно з ML-KEM-768 без пропорційного зростання рівня безпеки для типових сценаріїв автентифікації.

**Існуючі гібридні підходи.** Гібридні конструкції (класика + PQ) вже впроваджуються у виробничих системах:

**Таблиця 2.3 --- Існуючі гібридні постквантові протоколи**

| Протокол | Класична основа | PQ-компонент | Тип автентифікації | Парольна автентифікація |
|---|---|---|---|---|
| TLS 1.3 Hybrid [18] | X25519 | ML-KEM-768 | PKI-сертифікати | Ні |
| Signal PQXDH [19] | X3DH (X25519) | ML-KEM-1024 | Пакет попередніх ключів | Ні |
| WireGuard PQ [20] | Noise IK (X25519) | ML-KEM-768 | Статичні ключі | Ні |
| **Гібридний PQ-OPAQUE** | **4DH (Ristretto255)** | **ML-KEM-768** | **PAKE (OPRF + пароль)** | **Так** |

Жоден з існуючих гібридних протоколів не забезпечує парольної автентифікації: всі вони спираються на попередньо розповсюджені відкриті ключі або PKI-сертифікати.

### 2.4 Нові підходи до постквантових PAKE (2023–2025)

Проблема побудови постквантово стійкого PAKE є активною областю досліджень. Основні напрямки:

**Решітково-орієнтовані OPRF-замінники.** Конструкції забутливої псевдовипадкової функції на основі задачі Learning With Errors (LWE) та її кільцевих варіантів (Ring-LWE, Module-LWE) пропонуються як PQ-альтернативи Ristretto-OPRF. Ключова проблема --- суттєво більший розмір сліпих елементів та знижена ефективність порівняно з еліптичними кривими [40]. Типовий розмір засліпленого елемента в решітковому OPRF складає $\approx 10$--$30$ КБ, порівняно з 32 байтами для Ristretto255, що збільшує обсяг повідомлення реєстрації у $300$--$1000$ разів. Теоретичні рамки PQ-OPRF стосовно заміни в протоколі OPAQUE залишаються відкритою проблемою. Основна складність полягає у забезпеченні одночасно *засліпленості* та *псевдовипадковості* на решітках без використання ізогеній або білінійних пар.

**Ізогенні PAKE.** Протоколи на основі ізогеній (CSIDH, SQISign) пропонують компактні параметри (розмір ключа $\approx 64$ байти для CSIDH-512), однак атаки Castryck-Decru (2022) та повний злам SIKEp434 (2022) у поліноміальний час суттєво підірвали довіру до цього класу задач [41]. SIDH/SIKE-базовані PAKE вважаються небезпечними після публікації ефективної атаки відновлення ключа. Хоча CSIDH та SQISign поки не зламані, невизначеність щодо безпеки ізогенних конструкцій робить їх непридатними для стандартизації на теперішній момент.

**Чисто PQ aPAKE-конструкції.** Ряд наукових робіт 2023–2024 пропонує побудувати aPAKE безпосередньо з решіткових примітивів, уникаючи OPRF на еліптичних кривих. Однак такі конструкції мають:
- Більший розмір повідомлень (типово ×5–10 порівняно з OPAQUE);
- Відсутність верифікованих реалізацій промислового рівня;
- Менш дослідженість криптоаналізу порівняно з десятиліттями атак на класичні схеми.

**Гібридний підхід як оптимальний.** Консенсус спільноти (IETF CFRG, NIST PQC) схиляється до гібридизації як найбільш зрілого шляху: AND-модель безпеки гарантує збереження захисту навіть при виявленні вразливості в одному з компонентів [21]. Ключова перевага гібридного підходу --- *зниження ризику криптоаналітичного прориву*: ML-KEM-768 базується на задачі Module-LWE, яка досліджується приблизно 10 років (з перших робіт Regev [34] у 2005 році та модулярного варіанту з 2012 року), тоді як ECDLP на Curve25519 має понад 30 років криптоаналізу. AND-модель усуває необхідність робити ставку на один клас обчислювально важких задач. IETF CFRG розглядає стандартизацію гібридних PAKE як пріоритетне завдання, проте на момент проведення дослідження (2025) жоден стандарт не опублікований.

**Проміжок у літературі.** Систематичний аналіз літератури виявив три окремих проміжки:

1. *Відсутність гібридного PQ-OPAQUE.*
Жодна з існуючих публікацій не розглядає гібридне постквантове розширення *конкретно протоколу OPAQUE*.
2. *Відсутність формальної верифікації гібридних aPAKE.*
Існуючі гібридні протоколи (TLS, Signal, WireGuard) верифіковані для класичних версій, але їх PQ-розширення не мають символьної верифікації.
3. *Відсутність відкритих реалізацій.*
Не існує відкритих реалізацій гібридного PQ-PAKE з повним набором тестів та еталонних вимірювань.

Ці три проміжки є предметом даного дослідження.

### 2.5 Аналіз гібридних комбінаторів ключового матеріалу

Центральним конструктивним питанням гібридного ключового обміну є механізм об'єднання класичного та постквантового ключового матеріалу. У літературі виділяють чотири основних підходи [44]:

1. *XOR-then-KDF*: $K = \text{KDF}(ss_1 \oplus ss_2)$. Найпростіший варіант, використаний у ранніх чернетках TLS hybrid. Недолік: AND-модель не гарантується, оскільки XOR із нульовим $ss_2$ еквівалентний $ss_1$.
2. *Конкатенація-then-KDF*: $K = \text{KDF}(ss_1 \| ss_2)$. Використовується в Signal PQXDH [19] та TLS 1.3 Hybrid [18]. Гарантує AND-модель за умови PRF-стійкості KDF.
3. *Вкладений KDF*: $K = \text{KDF}_2(ss_2, \text{KDF}_1(ss_1, \text{salt}))$. Використовується в WireGuard PQ [20]. Забезпечує AND-модель, але вводить послідовну залежність.
4. *Dual-PRF комбінатор*: $K = \text{HKDF-Extract}(\text{salt}, ss_1 \| ss_2)$, де HMAC-SHA-512 задовольняє dual-PRF властивість [33]. Вихід є псевдовипадковим, якщо *хоча б один* із входів (IKM або сіль) є псевдовипадковим.

**Таблиця 2.1 --- Порівняння гібридних комбінаторів**

| Комбінатор | Протокол | Структура IKM | AND-модель | Додаткові властивості |
|---|---|---|---|---|
| XOR-then-KDF | Ранній TLS hybrid | $ss_1 \oplus ss_2$ | Ні | Мінімальний розмір |
| Конкатенація-then-KDF | Signal PQXDH, TLS 1.3 | $ss_1 \| ss_2$ | Так (PRF) | Простота |
| Вкладений KDF | WireGuard PQ | $\text{KDF}(ss_2, \text{KDF}(ss_1))$ | Так | Послідовна деривація |
| **Dual-PRF (HKDF-Extract)** | **Гібридний PQ-OPAQUE** | $dh_{1..4} \| ss_{\text{kem}}$ | **Так (dual-PRF)** | **Контекстна сіль** |

У цій роботі обрано dual-PRF комбінатор із контекстно-залежною сіллю: $\text{salt} = \text{``PQ-Combiner''} \| H(\tau)$, де $\tau$ --- розширений транскрипт. Ця конструкція забезпечує AND-модель через dual-PRF властивість HMAC [33, 44]: якщо IKM ($dh_{1..4} \| ss_{\text{kem}}$) є псевдовипадковим (навіть частково, через CDH або ML-KEM IND-CCA), PRK є псевдовипадковим незалежно від солі. Включення транскрипту до солі додатково зв'язує PRK з повним станом протоколу, запобігаючи крос-сесійному повторному використанню ключів.

---

## 3. ПОСТАНОВКА ЗАДАЧІ

### 3.1 Формулювання проблеми та модель загроз

Нехай $\mathcal{C}$ (клієнт/ініціатор) та $\mathcal{S}$ (сервер/респондер) --- дві сторони протоколу, де $\mathcal{C}$ володіє паролем $\text{pwd}$, а $\mathcal{S}$ зберігає реєстраційний запис $\text{rec}$. Позначимо через $\mathbb{G}$ групу Ristretto255 простого порядку $q$ з генератором $g$.

**Активи, що підлягають захисту:**
- Пароль $\text{pwd}$; статичні ключі $sk_C, sk_S$; ефемерні ключі $e_C, e_S, sk_{\text{kem}}$;
- Реєстраційний запис $\text{rec} = (\text{envelope}, pk_C)$;
- Сесійний ключ $K_s$, майстер-ключ $K_m$, спільний секрет $ss_{\text{kem}}$.

**Модель противника.** Розглядаємо три класи противників з різними обчислювальними спроможностями:

*Класичний противник $\mathcal{A}_C$*: поліноміально обмежений, активний «людина посередині», може компрометувати серверне сховище. Спроможності: перехоплення, модифікація та повторне відтворення мережевих повідомлень; компрометація довготривалих ключів ($sk_C, sk_S$); компрометація бази даних (конверт, OPRF-ключ). Не здатен розв'язувати задачу CDH на Ristretto255 або Module-LWE.

*Квантовий противник $\mathcal{A}_Q$*: має доступ до криптографічно значущого квантового комп'ютера. Спроможності: розв'язання DLP/ECDLP (алгоритм Шора) за поліноміальний час; відновлення приватних ключів із відкритих ключів Ristretto255; стратегія «збирай зараз --- дешифруй пізніше» з ретроспективним криптоаналізом збереженого трафіку. Не здатен розв'язувати задачу Module-LWE (основа безпеки ML-KEM-768).

*Композитний противник $\mathcal{A}_{CQ}$*: поєднує спроможності $\mathcal{A}_C$ та $\mathcal{A}_Q$ --- активний «людина посередині» із квантовим обчислювальним оракулом. Цей клас є найсильнішим і відповідає загрозі, проти якої проєктується гібридний протокол. Формальна верифікація Tamarin моделює $\mathcal{A}_{CQ}$ через поєднання правил `CorruptS`/`CorruptC` (класичний компонент) та відсутність обмежень на знання DH-секретів (квантовий компонент).

**Вимоги до протоколу:**
- **R1** (OPAQUE-властивості): таємність пароля, пряма секретність, взаємна автентифікація, стійкість до офлайн-перебирання;
- **R2** (Постквантова стійкість): захист від стратегії «збирай зараз --- дешифруй пізніше»;
- **R3** (AND-модель): для зламу необхідно подолати *обидві* обчислювально важкі задачі (ECDLP та Module-LWE);
- **R4** (Мінімальні накладні витрати): збереження 3 повідомлень та 1,5 раундів обміну;
- **R5** (Реалізованість): кросплатформна промислова реалізація.

### 3.2 Формальні визначення

**Визначення 1** (KEM). $(\text{KeyGen}, \text{Encaps}, \text{Decaps})$: $\text{KeyGen}() \to (pk, sk)$; $\text{Encaps}(pk) \to (ct, ss)$; $\text{Decaps}(sk, ct) \to ss$. IND-CCA2 безпека: жоден поліноміально обмежений противник з оракулом декапсуляції не відрізняє реальний $ss$ від випадкового.

**Визначення 2** (Гібридний aPAKE). Протокол $\Pi$ між $\mathcal{C}(\text{pwd})$ та $\mathcal{S}(\text{rec})$, де ключовий матеріал формується з класичного (ECDLP-based) та постквантового (lattice KEM) джерел, а безпека гарантується за умови складності хоча б однієї задачі.

**Визначення 3** (PRF-безпека HKDF). $\text{HKDF-Extract}(\text{salt}, \text{IKM})$ на основі HMAC-SHA-512 є $\varepsilon$-PRF: вихід $\text{PRK}$ обчислювально невідрізнимий від рівномірного за перевагою не більше $\varepsilon$.

**Визначення 4** (Безпека OPRF --- забутлива псевдовипадковість). Нехай $F_k: X \to Y$ --- сімейство функцій з ключем $k$. OPRF-протокол є $(t, \varepsilon)$-безпечним, якщо жоден противник, що працює за час $t$, не може відрізнити $F_k(x)$ від рівномірно випадкового значення для будь-якого $x$, не запитаного до оракулу обчислення, з перевагою більшою за $\varepsilon$. Для Ristretto255-OPRF: $\varepsilon \leq \text{Adv}_{\text{CDH}}^{\text{Ristretto255}}$ --- безпека OPRF зводиться до задачі обчислювального Діффі--Геллмана.

**Визначення 5** (Пряма секретність гібридного AKE). Протокол $\Pi$ забезпечує пряму секретність, якщо для будь-якого противника $\mathcal{A}$, що отримує довготривалі ключі $(sk_C, sk_S)$ *після* завершення сесії (момент часу $t_{\text{reveal}} > t_{\text{session}}$) та запитує тестовий оракул для сесійного ключа, перевага розрізнення реального ключа від випадкового є нехтовно малою: $\text{Adv}_{\Pi}^{\text{FS}}(\mathcal{A}) \leq \text{negl}(\lambda)$, де $\lambda$ --- параметр безпеки [45].

**Визначення 6** (AND-модель гібридної безпеки). Протокол $\Pi$ з класичним ($\Sigma_C$) та постквантовим ($\Sigma_{PQ}$) компонентами задовольняє AND-модель, якщо для будь-якого противника $\mathcal{A}$, що має доступ *або* до квантового DH-оракулу (зламує $\Sigma_C$), *або* до оракулу декапсуляції KEM (зламує $\Sigma_{PQ}$), але *не до обох одночасно*, сесійний ключ залишається невідрізнимим від випадкового: $\text{Adv}_{\Pi}^{\text{AND}}(\mathcal{A}) \leq \min(\text{Adv}_{\Sigma_C}, \text{Adv}_{\Sigma_{PQ}}) + \text{negl}(\lambda)$.

**Нотація:** $\mathbb{G}$ --- Ristretto255, $|\mathbb{G}| = q$; малі літери --- скаляри; великі --- точки кривої; $\|$ --- конкатенація; $H(\cdot)$ --- SHA-512; $\mathcal{K} = (K_s, K_m)$ --- сесійний та майстер-ключ.

---

## 4. ЗАПРОПОНОВАНИЙ ПРОТОКОЛ: HYBRID PQ-OPAQUE

### 4.1 Архітектура та огляд

Гібридний PQ-OPAQUE є постквантовою гібридною модифікацією протоколу OPAQUE [6]. Протокол зберігає властивість aPAKE (сервер не отримує доступу до пароля) та додає стійкість до стратегії «збирай зараз --- дешифруй пізніше». Протокол має дві фази: *реєстрація* (одноразова процедура) та *автентифікація* (тристороннє повідомлення KE1--KE2--KE3 із завершенням на стороні сервера).

**Потік повідомлень фази автентифікації:**

$$\mathcal{C} \xrightarrow{\text{KE1}: B \| E_C \| n_C \| pk_{\text{kem}}} \mathcal{S}$$
$$\mathcal{C} \xleftarrow{\text{KE2}: n_S \| E_S \| \text{CredResp} \| \text{MAC}_S \| ct_{\text{kem}}} \mathcal{S}$$
$$\mathcal{C} \xrightarrow{\text{KE3}: \text{MAC}_C} \mathcal{S}$$
$$\mathcal{C} \quad \xleftarrow{\text{Server Finish (implicit)}} \quad \mathcal{S}$$

Фаза реєстрації виконується одноразово та складається з трьох кроків: (1) клієнт надсилає засліплений OPRF-запит; (2) сервер обчислює OPRF-відповідь та повертає свій відкритий ключ; (3) клієнт фіналізує OPRF, обчислює Argon2id, запечатує конверт та передає реєстраційний запис серверу. Фаза автентифікації використовує 1,5 обміни (3 повідомлення): ініціатор розпочинає, респондер відповідає із зашифрованим конвертом та ефемерними ключами, ініціатор завершує автентифікацію MAC-підтвердженням.

**Таблиця 2 --- Криптографічні примітиви Hybrid PQ-OPAQUE**

| Компонент | Примітив | Реалізація (Rust) | Рівень безпеки |
|---|---|---|---|
| Група OPRF | Ristretto255 / Curve25519 | `libsodium-sys-stable` | 128 біт (класичний) |
| Геш-функція | SHA-512 | `libsodium-sys-stable` | 256 біт |
| Функція виведення ключів (витяг) | HKDF-Extract (HMAC-SHA-512) | `libsodium-sys-stable` | 256 біт |
| Функція виведення ключів (розширення) | HKDF-Expand (HMAC-SHA-512) | `libsodium-sys-stable` | 256 біт |
| Код автентифікації повідомлень | HMAC-SHA-512 | `libsodium-sys-stable` | 256 біт |
| Функція жорсткого перетворення пароля | Argon2id (параметри MODERATE) | `libsodium-sys-stable` | Адаптивний |
| Автентифіковане симетричне шифрування | XSalsa20-Poly1305 | `libsodium-sys-stable` | 256 біт |
| Постквантова інкапсуляція ключів | ML-KEM-768 (FIPS 203) | `ml-kem` (чистий Rust) | NIST Рівень 3 |
| Класичний ключовий обмін | 4DH на Ristretto255 | `libsodium-sys-stable` | 128 біт (класичний) |

**Таблиця 3 --- Константи протоколу (байти)**

| Параметр | Розмір |
|---|---|
| Приватний/відкритий ключ Ristretto255 | 32 |
| Nonce | 24 |
| MAC (HMAC-SHA-512) | 64 |
| Envelope | 136 |
| Відкритий ключ ML-KEM-768 | 1184 |
| Шифротекст ML-KEM-768 | 1088 |
| Спільний секрет ML-KEM-768 | 32 |
| Комбінований IKM | 160 |

**Таблиця 4 --- Розміри повідомлень автентифікації**

| Повідомлення | Класичний OPAQUE | Гібридний PQ-OPAQUE | Накладні витрати |
|---|---|---|---|
| KE1 | 88 байт | 1272 байт | +1184 ($pk_{\text{kem}}$) |
| KE2 | 288 байт | 1376 байт | +1088 ($ct_{\text{kem}}$) |
| KE3 | 64 байт | 64 байт | 0 |
| **Разом** | **440 байт** | **2712 байт** | **+2272 (+516%)** |

### 4.2 Фаза реєстрації

**Крок 1 ($\mathcal{C} \to \mathcal{S}$).** Генерація статичної пари $(sk_C, PK_C)$; OPRF-засліплення:
$$r \xleftarrow{\$} \mathbb{Z}_q^*, \quad B = r \cdot H'(\text{"ECLIPTIX-OPAQUE-v1/OPRF"} \| \texttt{0x00} \| \text{pwd})$$
$\text{RegistrationRequest} = B$ (32 байти).

**Крок 2 ($\mathcal{S} \to \mathcal{C}$).** Виведення OPRF-ключа через HKDF з глобального насіння:
$$k_{\text{oprf}} = \text{ScalarReduce}\bigl(\text{HKDF}(\text{oprf\_seed},\; \text{"OPRF-Key"} \| \text{account\_id})\bigr);$$
де ScalarReduce використовує ітеративний підхід з лічильником (0..254) для уникнення систематичної похибки при редукції до скалярного поля.

Обчислення $Z = k_{\text{oprf}} \cdot B$; відповідь $= Z \| PK_S$ (64 байти). Ключ $k_{\text{oprf}}$ негайно знищується після обчислення.

**Крок 3 ($\mathcal{C}$).** OPRF-розсліплення $U = r^{-1} \cdot Z$; фіналізація: вихід OPRF обчислюється як $\text{SHA-512}(\text{"ECLIPTIX-OPAQUE-v1/OPRF"} \| \texttt{0x01} \| \text{pwd} \| U)$. Рандомізований пароль:
$$\text{rwd} = \text{Argon2id}(H(\text{"KSF"} \| U \| \text{pwd}), \text{salt})$$
Деривація ключа шифрування конверта:
$$K_{\text{env}} = \text{HKDF-Expand}\bigl(\text{HKDF-Extract}(\text{``envelope\_key''}, \text{rwd} \| PK_S),\; \text{``Envelope''},\; 32\bigr)$$
Зв'язування з $PK_S$ є критичним: навіть при відомому паролі, конверт, запечатаний для сервера $\mathcal{S}_1$, не може бути відкритий для автентифікації на $\mathcal{S}_2$ (оскільки $K_{\text{env}}^{(1)} \neq K_{\text{env}}^{(2)}$). Запечатування виконується автентифікованим шифруванням XSalsa20-Poly1305 з випадковим nonce (24 байти). Конверт містить: nonce (24 б) + зашифрований текст ($sk_C \| PK_C$ = 64 б, після шифрування 96 б через внутрішнє доповнення) + тег автентифікації Poly1305 (16 б) = 136 байт. Реєстраційний запис: $\text{RegistrationRecord} = \text{Envelope} \| PK_C$ (136 + 32 = 168 байт).

### 4.3 Фаза автентифікації: гібридний ключовий обмін

#### 4.3.1 Генерація KE1 ($\mathcal{C} \to \mathcal{S}$)

$$e_C \xleftarrow{\$} \mathbb{Z}_q^*, \ E_C = e_C \cdot g; \quad (pk_{\text{kem}}, sk_{\text{kem}}) \leftarrow \text{ML-KEM-768.KeyGen}(); \quad n_C \xleftarrow{\$} \{0,1\}^{192}$$
$$\text{KE1} = B \| E_C \| n_C \| pk_{\text{kem}} \quad (32 + 32 + 24 + 1184 = 1272 \text{ байти})$$

Ініціатор зберігає стан сесії: $(r, e_C, sk_{\text{kem}}, n_C, \text{pwd})$. Засліплюючий скаляр $r$, ефемерний ключ $e_C$ та приватний ключ KEM $sk_{\text{kem}}$ є *одноразовими* --- вони генеруються випадково для кожної сесії та знищуються після використання. Відкритий ключ $pk_{\text{kem}}$ (1184 байти) є домінуючим компонентом розміру KE1, що обумовлює зростання обсягу повідомлення з 88 байт (класичний) до 1272 байт (гібридний).

#### 4.3.2 Генерація KE2 ($\mathcal{S} \to \mathcal{C}$)

**Чотиристоронній Діффі-Геллман (4DH):**
$$dh_1 = sk_S \cdot PK_C, \quad dh_2 = sk_S \cdot E_C, \quad dh_3 = e_S \cdot PK_C, \quad dh_4 = e_S \cdot E_C$$

**Інкапсуляція ML-KEM-768:**
$$(ct_{\text{kem}}, ss_{\text{kem}}) \leftarrow \text{ML-KEM-768.Encaps}(pk_{\text{kem}})$$

**Розширений транскрипт** (включає PQ-елементи):
$$\tau = E_C \| E_S \| n_C \| n_S \| PK_C \| PK_S \| \text{CredResp} \| pk_{\text{kem}} \| ct_{\text{kem}}$$
$$\text{transcript\_hash} = H(\text{"ECLIPTIX-OPAQUE-v1/Transcript"} \| \tau)$$

**Гібридний комбінатор (наукова новизна):**
$$\text{combined\_ikm} = dh_1 \| dh_2 \| dh_3 \| dh_4 \| ss_{\text{kem}} \quad (128 + 32 = 160 \text{ байт})$$
$$\text{salt} = \text{"ECLIPTIX-OPAQUE-PQ-v1/Combiner"} \| \text{transcript\_hash}$$
$$\text{PRK} = \text{HKDF-Extract}(\text{salt}, \text{combined\_ikm})$$

**Деривація ключів:**
$$K_s = \text{HKDF-Expand}(\text{PRK}, \text{"SessionKey"}, 64); \quad K_m = \text{HKDF-Expand}(\text{PRK}, \text{"MasterKey"}, 32)$$
$$K_{\text{mac}}^S = \text{HKDF-Expand}(\text{PRK}, \text{"ResponderMAC"}, 64); \quad K_{\text{mac}}^C = \text{HKDF-Expand}(\text{PRK}, \text{"InitiatorMAC"}, 64)$$

*Примітка:* Мітки у наведених формулах скорочені для стислості. Повні доменно-розділові мітки у реалізації мають вигляд `ECLIPTIX-OPAQUE-PQ-v1/SessionKey`, `ECLIPTIX-OPAQUE-PQ-v1/MasterKey`, `ECLIPTIX-OPAQUE-PQ-v1/ResponderMAC`, `ECLIPTIX-OPAQUE-PQ-v1/InitiatorMAC`. Аналогічно, у фазі реєстрації: `ECLIPTIX-OPAQUE-v1/OPRF-Key`, `ECLIPTIX-OPAQUE-v1/KSF`.

**Порядок знищення ключового матеріалу.** Після деривації $K_s$, $K_m$, $K_{\text{mac}}^S$ та $K_{\text{mac}}^C$ респондер негайно знищує: (1) ефемерний приватний ключ $e_S$; (2) спільний секрет $ss_{\text{kem}}$; (3) масив комбінованого IKM (160 байт); (4) PRK. Ключ $sk_{\text{kem}}$ знищується на стороні ініціатора після декапсуляції. Цей послідовний каскад знищення гарантує *мінімальний час життя* чутливого ключового матеріалу в пам'яті.

$$\text{KE2} = n_S \| E_S \| \text{CredResp} \| \text{HMAC}(K_{\text{mac}}^S, \tau) \| ct_{\text{kem}} \quad (1376 \text{ байт})$$

#### 4.3.3 Генерація KE3 ($\mathcal{C} \to \mathcal{S}$)

1. OPRF-фіналізація, відкриття конверта, відновлення $(PK_S, sk_C, PK_C)$;
2. Дзеркальний 4DH: $dh_1 = sk_C \cdot PK_S$, $dh_2 = e_C \cdot PK_S$, $dh_3 = sk_C \cdot E_S$, $dh_4 = e_C \cdot E_S$ (UKS-стійкість);
3. Декапсуляція: $ss_{\text{kem}} = \text{ML-KEM-768.Decaps}(sk_{\text{kem}}, ct_{\text{kem}})$; $sk_{\text{kem}}$ негайно знищується;
4. Ідентична деривація PRK; верифікація $\text{HMAC}(K_{\text{mac}}^S, \tau)$ через рівночасовий аналог порівняння `sodium_memcmp`;
5. $\text{KE3} = \text{HMAC}(K_{\text{mac}}^C, \tau)$ (64 байти).

#### 4.3.4 Server Finish

Верифікація $\text{KE3}$ рівночасовою функцією порівняння `sodium_memcmp`. При успіху --- пара $(K_s, K_m)$ стає доступною обом сторонам, підтверджуючи взаємну автентифікацію та завершуючи протокол. Сесійний ключ $K_s$ (64 байти) використовується для шифрування подальшого трафіку; майстер-ключ $K_m$ (32 байти) може використовуватися для деривації додаткових ключів у прикладному рівні.

При відмові верифікації MAC --- всі ключові матеріали ($K_s$, $K_m$, $K_{\text{mac}}^S$, $K_{\text{mac}}^C$, PRK, $ss_{\text{kem}}$) негайно знищуються в пам'яті через безпечне затирання (`zeroize`). Функція `responder_finish` повертає код помилки `AuthenticationError` (-5) *після* знищення всіх чутливих даних, що запобігає витоку ключового матеріалу через обробку виключних ситуацій.

### 4.4 Включення PQ-елементів у транскрипт

Включення $pk_{\text{kem}}$ та $ct_{\text{kem}}$ у транскрипт є **криптографічно необхідним**: воно *криптографічно зв'язує* постквантовий обмін з класичним. Розглянемо контрприклад: нехай транскрипт $\tau'$ не включає PQ-елементи. Тоді противник $\mathcal{A}$ може виконати наступну атаку:
1. $\mathcal{A}$ перехоплює KE1 від $\mathcal{C}$ та замінює $pk_{\text{kem}}$ власним ключем $pk_{\text{kem}}^*$;
2. $\mathcal{S}$ виконує інкапсуляцію з $pk_{\text{kem}}^*$, отримуючи $(ct^*, ss^*)$;
3. $\mathcal{A}$ декапсулює $ct^*$ своїм секретним ключем, отримуючи $ss^*$;
4. Оскільки $\tau'$ не містить $pk_{\text{kem}}$ та $ct_{\text{kem}}$, MAC обчислюється на PRK, що включає $ss^*$ (відоме $\mathcal{A}$). Проте $\mathcal{A}$ все ще не знає класичних DH-секретів, тому не може обчислити повний PRK.

Включення PQ-елементів у транскрипт закриває навіть *часткову* компрометацію: будь-яка модифікація $pk_{\text{kem}}$ або $ct_{\text{kem}}$ призводить до незбіжності гешу $H(\tau)$, що входить до солі гібридного комбінатора, і відповідно --- до незбіжності PRK та всіх похідних MAC.

### 4.5 Обґрунтування конструктивних рішень

#### 4.5.1 Четвертий добуток Діффі--Геллмана замість третього

Специфікація IETF `draft-irtf-cfrg-opaque` [6] визначає тристоронній обмін: $dh_1 = sk_S \cdot PK_C$ (взаємна автентифікація), $dh_2 = sk_S \cdot E_C$ та $dh_3 = e_S \cdot PK_C$ (пряма секретність). У цій роботі додано четвертий добуток $dh_4 = e_S \cdot E_C$, що забезпечує стійкість до атаки підміни ключа (Unknown Key Share, UKS).

Без $dh_4$ противник, який знає $sk_C$ (компрометація клієнта), може обчислити $dh_1$ та $dh_3$ для довільного сервера, потенційно спричинивши ситуацію, де клієнт помилково вважає, що автентифікувався з іншим сервером. $dh_4$ вводить залежність від *ефемерного* ключа сервера $e_S$, який є унікальним для кожної сесії та знищується після завершення, закриваючи цей вектор атаки (Теорема 5).

Обчислювальна вартість $dh_4$ --- одне додаткове скалярне множення ($\approx 41$ мкс на Apple M1 Pro), що складає менше 0,01% від наскрізного часу автентифікації.

#### 4.5.2 Обов'язкова інтеграція механізму інкапсуляції ключів

ML-KEM-768 є *обов'язковою* складовою протоколу, а не факультативним розширенням. Це конструктивне рішення обумовлене захистом від атаки зниження рівня безпеки (downgrade attack). Оскільки повідомлення KE1 надсилається *до* автентифікації, клієнт не має автентифікованого механізму сигналізації PQ-спроможності. Якби ML-KEM-768 був факультативним, противник типу «людина посередині» міг би видалити поле $pk_{\text{kem}}$ із KE1, перевівши протокол у класичний режим без відома обох сторін.

Включення $pk_{\text{kem}}$ та $ct_{\text{kem}}$ у транскрипт $\tau$ (Підрозділ 4.4) гарантує, що обидві сторони узгоджують наявність KEM-обміну: якщо противник видалить $pk_{\text{kem}}$ з KE1, геші транскриптів не збігатимуться, і коди автентифікації повідомлень відхилять підроблені повідомлення. Обов'язковість інтеграції усуває потребу в механізмі узгодження версій (version negotiation), спрощуючи протокол.

#### 4.5.3 Доменне розділення та мічені ключові деривації

Реалізація використовує систему *доменного розділення* на основі мічених рядків для запобігання плутанині ключів (key confusion) та крос-протокольним атакам. Визначено два простори імен:

- `ECLIPTIX-OPAQUE-v1/` --- класичні операції (OPRF, конверт, функція жорсткого перетворення);
- `ECLIPTIX-OPAQUE-PQ-v1/` --- гібридні операції (комбінатор, деривація ключів).

Загалом визначено 12 окремих міток для кожної точки деривації ключів: `OPRF`, `KSF`, `Envelope`, `Transcript`, `Combiner`, `SessionKey`, `MasterKey`, `ResponderMAC`, `InitiatorMAC`, `OPRF-Key` та інші. Кожна мітка є унікальним рядком, що гарантує: навіть при ідентичних вхідних даних, деривовані ключі для різних цілей будуть різними. Сіль гібридного комбінатора включає *як* мітку `PQ_COMBINER_CONTEXT`, *так* і геш транскрипту, зв'язуючи деривацію PRK із повним станом протоколу.

#### 4.5.4 Безстановий OPRF-ключ респондера

Класична архітектура OPAQUE вимагає зберігання окремого OPRF-ключа для кожного облікового запису. У цій реалізації OPRF-ключі деривовано *детерміністично* з єдиного глобального насіння (`oprf_seed`) респондера:
$$k_{\text{oprf}} = \text{ScalarReduce}\bigl(\text{HMAC}(\text{oprf\_seed}, \text{``OPRF-Key''} \| \text{account\_id} \| \text{counter})\bigr)$$

Лічильний метод (try-and-increment) гарантує ненульовість отриманого скаляра: якщо результат скалярної редукції дорівнює нулю ($\Pr \approx 2^{-252}$), лічильник інкрементується і обчислення повторюється (максимум 255 ітерацій). На практиці перша ітерація завжди успішна.

Ця конструкція забезпечує *безстановість* респондера: серверу достатньо зберігати єдиний секрет `oprf_seed` замість окремого OPRF-ключа для кожного облікового запису. Схема бази даних не змінюється при додаванні нових облікових записів (за винятком реєстраційного запису). З точки зору безпеки, компрометація `oprf_seed` еквівалентна компрометації всіх OPRF-ключів --- це відповідає моделі загроз серверного ключа у специфікації IETF [6].

---

## 5. АНАЛІЗ БЕЗПЕКИ

### 5.1 Формальний аналіз властивостей безпеки

**Теорема 1** (Секретність паролю). *Перевага противника у визначенні пароля є нехтовно малою за умови: (1) забутькуватості OPRF на Ristretto255; (2) стійкості Argon2id; (3) семантичної стійкості XSalsa20-Poly1305.*

*Доведення (ескіз методом покрокової гральної редукції).* **Гра 0** → **Гра 1**: замінюємо вихід OPRF рівномірно випадковим; обчислювальна нерозрізненність за властивістю забутливості OPRF:
$$|\Pr[S_1] - \Pr[S_0]| \leq \text{Adv}_{\text{OPRF}}^{\text{obliv}} \leq \text{Adv}_{\text{Ristretto255}}^{\text{CDH}}.$$

**Гра 1** → **Гра 2**: замінюємо вихід Argon2id випадковим ключем; нерозрізнимість за memory-hard властивістю PRF:
$$|\Pr[S_2] - \Pr[S_1]| \leq \text{Adv}_{\text{Argon2id}}^{\text{PRF}}.$$

**Гра 2** → **Гра 3**: замінюємо envelope шифруванням випадкового рядка; за IND-CPA XSalsa20-Poly1305:
$$|\Pr[S_3] - \Pr[S_2]| \leq \text{Adv}_{\text{XSalsa20}}^{\text{IND-CPA}}.$$

У Грі 3: $\text{Adv}^{\text{pw}} = 1/|\mathcal{D}|$. Загальна перевага:
$$\text{Adv}^{\text{pw}} \leq \text{Adv}_{\text{CDH}}^{\text{Ristretto255}} + \text{Adv}_{\text{Argon2id}}^{\text{PRF}} + \text{Adv}_{\text{XSalsa20}}^{\text{IND-CPA}} + \frac{1}{|\mathcal{D}|}. \quad \blacksquare$$

**Теорема 2** (Пряма секретність). *Компрометація довготривалих ключів $sk_C, sk_S$ після завершення сесії не дозволяє відновити $K_s$, за умови складності CDH та IND-CCA безпеки ML-KEM-768.*

*Доведення (ескіз методом покрокової гральної редукції).* Нехай $\mathcal{A}$ --- противник, що після завершення цільової сесії отримує довготривалі ключі $(sk_C, sk_S)$ та намагається відрізнити реальний сесійний ключ $K_s$ від випадкового.

**Гра 0** (реальна): $\mathcal{A}$ взаємодіє з реальним протоколом та отримує $(sk_C, sk_S)$ після закінчення сесії. $\mathcal{A}$ знає $dh_1 = sk_S \cdot PK_C$ (обчислюється з розкритих ключів).

**Гра 0** → **Гра 1**: замінюємо $dh_2 = sk_S \cdot E_C$ випадковим елементом $\mathbb{G}$. Нерозрізненність: $\mathcal{A}$ знає $sk_S$ та $E_C = e_C \cdot g$ (відкрите), але *не* $e_C$ (знищено після сесії). Обчислення $sk_S \cdot E_C$ без $e_C$ зводиться до задачі CDH на Ristretto255: $|\Pr[S_1] - \Pr[S_0]| \leq \text{Adv}_{\text{CDH}}^{\text{Ristretto255}}$.

**Гра 1** → **Гра 2**: аналогічно замінюємо $dh_3 = e_S \cdot PK_C$ та $dh_4 = e_S \cdot E_C$ випадковими елементами. Ефемерний $e_S$ знищено: $|\Pr[S_2] - \Pr[S_1]| \leq 2 \cdot \text{Adv}_{\text{CDH}}^{\text{Ristretto255}}$.

**Гра 2** → **Гра 3**: замінюємо $ss_{\text{kem}}$ випадковим значенням. $dk_{\text{kem}}$ знищено після декапсуляції; за IND-CCA2 безпекою ML-KEM-768: $|\Pr[S_3] - \Pr[S_2]| \leq \text{Adv}_{\text{ML-KEM}}^{\text{IND-CCA}}$.

У Грі 3 вхід HKDF-Extract є повністю випадковим, тому PRK та похідний $K_s$ невідрізнимі від випадкових. Загальна перевага:
$$\text{Adv}^{\text{FS}} \leq 3 \cdot \text{Adv}_{\text{CDH}}^{\text{Ristretto255}} + \text{Adv}_{\text{ML-KEM}}^{\text{IND-CCA}} + \text{Adv}_{\text{HMAC}}^{\text{dual-PRF}}. \quad \blacksquare$$

**Теорема 3** (Взаємна автентифікація). *Ймовірність підробки MAC є нехтовно малою за умови PRF-стійкості HMAC-SHA-512.*

*Доведення (ескіз).* Коди автентифікації повідомлень обчислюються як $\text{MAC}_S = \text{HMAC}(K_{\text{mac}}^S, \tau)$ та $\text{MAC}_C = \text{HMAC}(K_{\text{mac}}^C, \tau)$, де ключі $K_{\text{mac}}^S$ та $K_{\text{mac}}^C$ деривовано з PRK через HKDF-Expand з різними мітками. Нехай $\mathcal{A}$ --- противник, що намагається підробити MAC без знання PRK. Якщо $\mathcal{A}$ підробляє MAC з нехтовно малою перевагою, ми конструюємо редукцію $\mathcal{B}$, що зламує PRF-безпеку HMAC-SHA-512: $\mathcal{B}$ замінює $\text{HMAC}(K_{\text{mac}}, \cdot)$ оракулом PRF та передає відповіді $\mathcal{A}$. Будь-яка успішна підробка дає $\mathcal{B}$ розрізнення PRF від випадкового. При $q_s$ сесіях ймовірність колізії транскрипту (яка дозволила б повторне використання MAC без підробки) обмежена $q_s / 2^{512}$ через 512-бітний вихід HMAC-SHA-512:

$\text{Adv}^{\text{auth}} \leq \text{Adv}_{\text{HMAC}}^{\text{PRF}} + q_s / 2^{512}$. $\blacksquare$

**Теорема 4** (Гібридна безпека --- AND-модель). *Якщо хоча б одна з умов виконується: (a) $dh_1 \| dh_2 \| dh_3$ псевдовипадкові (CDH); або (b) $ss_{\text{kem}}$ псевдовипадковий (ML-KEM IND-CCA) --- тоді PRK є псевдовипадковим.*

*Доведення (ескіз).* За dual-PRF властивістю HKDF-Extract [33]: якщо IKM є псевдовипадковим (навіть частково), PRK є псевдовипадковим незалежно від солі. Два випадки дають:
$$\text{Adv}^{\text{hybrid}} \leq \min\left(\text{Adv}_{\text{CDH}}^{\text{Ristretto255}}, \text{Adv}_{\text{ML-KEM}}^{\text{IND-CCA}}\right) + \text{Adv}_{\text{HMAC}}^{\text{dual-PRF}}. \quad \blacksquare$$

**Теорема 5** (Стійкість до атаки підміни ключа, UKS). *Противник не може спричинити ситуацію, в якій клієнт $\mathcal{C}$ та сервер $\mathcal{S}$ встановлюють спільний сесійний ключ $K_s$, тоді як $\mathcal{C}$ вважає, що комунікує з іншим сервером $\mathcal{S}' \neq \mathcal{S}$, за умови складності CDH на Ristretto255.*

*Доведення (ескіз методом редукції).* Нехай $\mathcal{A}$ --- противник, що здійснює атаку підміни ключа. Для успіху $\mathcal{A}$ має забезпечити, щоб клієнт прийняв MAC, обчислений під ключем $K_{\text{mac}}^S$, деривованим від PRK. PRK залежить від чотирьох добутків Діффі--Геллмана, зокрема $dh_4 = e_S \cdot E_C$. Саме $dh_4$ унеможливлює підміну: якщо $\mathcal{A}$ перенаправляє $\mathcal{C}$ до $\mathcal{S}' \neq \mathcal{S}$, то $\mathcal{S}'$ генерує власний ефемерний ключ $e_{S'}$, і $dh_4' = e_{S'} \cdot E_C \neq dh_4 = e_S \cdot E_C$. Відповідно, $\text{PRK}' \neq \text{PRK}$ та MAC не збігатиметься. Без $dh_4$ (у схемі 3DH) противник, що знає $sk_C$, може обчислити $dh_1 = sk_C \cdot PK_{S'} = sk_C \cdot PK_S$ (якщо $PK_{S'} = PK_S$, тобто при ретрансляції статичного ключа) та $dh_3 = e_S \cdot PK_C$, потенційно підмінивши ідентичність сервера. Четвертий добуток $dh_4$ вводить залежність від *ефемерного* ключа сервера, знищеного після сесії, закриваючи цей вектор атаки:
$$\text{Adv}^{\text{UKS}} \leq \text{Adv}_{\text{CDH}}^{\text{Ristretto255}}. \quad \blacksquare$$

*Зауваження.* Специфікація IETF `draft-irtf-cfrg-opaque` [6] використовує 3DH і не включає четвертий добуток $dh_4 = e_S \cdot E_C$. Включення $dh_4$ у Гібридному PQ-OPAQUE є свідомим конструктивним рішенням, що забезпечує UKS-стійкість ціною одного додаткового скалярного множення ($\approx 41$ мкс на Apple M1 Pro).

### 5.2 Стійкість до відомих атак

**Атаки офлайн-перебирання за словником.** Захист реалізовано на трьох незалежних рівнях: (1) OPRF --- без серверного ключа $k_{\text{oprf}}$ противник не може обчислити $\text{rwd}$ для жодного кандидата словника; (2) Argon2id із параметрами MODERATE (256 MiB, 3 ітерації) --- $C_{\text{offline}} \geq |\mathcal{D}| \cdot 500\text{ мс}$, роблячи повний перебір обчислювально непридатним; (3) XSalsa20-Poly1305 --- верифікація будь-якого кандидата потребує успішного автентифікованого розшифрування.

**Атака «людина посередині».** Транскрипт $\tau$ включає *всі* відкриті елементи, зокрема $pk_{\text{kem}}$ та $ct_{\text{kem}}$. Модифікація будь-якого поля призводить до незбіжності кодів автентифікації повідомлень.

**Атака повторного відтворення.** Ефемерні одноразові числа (192 біти), ефемерні ключі Діффі--Геллмана та ефемерна пара ключів ML-KEM генеруються заново для кожної окремої сесії за допомогою криптографічно стійкого генератора випадкових чисел (`randombytes_buf` бібліотеки libsodium, що використовує операційну систему як джерело ентропії). Ймовірність колізії одноразових чисел дорівнює $2^{-192}$. Навіть при $2^{64}$ сесіях (парадокс днів народження) ймовірність колізії становить $2^{-64}$ --- нехтовно мала величина. Повторне відтворення старого KE1 генерує інший транскрипт $\tau'$ (через нові ефемерні ключі сервера), що призводить до незбіжності MAC.

**Атака типу «збирай зараз --- дешифруй пізніше».** Це є центральною загрозою, проти якої проєктується гібридний протокол. Нехай квантовий противник перехопив повідомлення KE1, KE2, KE3 та зберіг їх для майбутнього криптоаналізу. Навіть при відновленні *всіх* чотирьох класичних DH-секретів ($dh_1, dh_2, dh_3, dh_4$) за допомогою алгоритму Шора, $ss_{\text{kem}}$ залишається захищеним механізмом ML-KEM-768 (Module-LWE, рівень безпеки NIST Level 3, еквівалентний AES-192, навіть для квантового противника). Оскільки PRK = HKDF-Extract(salt, $dh_{1..4} \| ss_{\text{kem}}$), а $ss_{\text{kem}}$ залишається псевдовипадковим, PRK та всі похідні ключі залишаються захищеними. Це є формальним підтвердженням стійкості до стратегії SNDL.

**Атака на компрометований ключ ініціатора (KCI).** Компрометація $sk_S$ не надає доступу до $dh_2 = sk_S \cdot E_C$ після закінчення сесії (залежить від знищеного ефемерного $e_C$) та до $ss_{\text{kem}}$ (залежить від знищеного $sk_{\text{kem}}$).

**Атака підміни ключа (UKS).** Четвертий добуток Діффі--Геллмана $dh_4 = e_S \cdot E_C$ забезпечує стійкість до UKS (Теорема 5). При відсутності $dh_4$ (класичний 3DH) противник, що скомпрометував $sk_C$, може ретранслювати статичний відкритий ключ одного сервера іншому, спричинивши збіжність $dh_1$ та $dh_3$ між різними серверами. Ефемерний $dh_4$ унеможливлює цю атаку, оскільки кожен сервер генерує унікальний $e_S$ для кожної сесії.

**Атака експорту облікових даних між серверами.** Ключ шифрування конверта деривовано як $\text{envelope\_key} = H(\text{``envelope\_key''} \| \text{rwd} \| PK_S)$, де $PK_S$ --- відкритий ключ конкретного сервера. Навіть якщо противник знає пароль і отримує конверт від сервера $\mathcal{S}_1$, він не зможе використати цей конверт для автентифікації на сервері $\mathcal{S}_2$, оскільки $PK_{S_1} \neq PK_{S_2}$ і, відповідно, ключі шифрування конвертів не збігатимуться.

**Атака через часовий бічний канал.** Реалізація забезпечує рівночасовість на трьох рівнях: (1) *порівняння MAC*: функція `sodium_memcmp` виконує побайтове порівняння без раннього виходу при першій відмінності, що запобігає часовій атаці на код автентифікації; (2) *скалярне множення*: Ristretto255 реалізовано в бібліотеці libsodium з використанням сходів Монтгомері (Montgomery ladder) та умовного присвоєння без розгалуження (conditional swap), що забезпечує рівночасовість незалежно від бітів скаляра; (3) *ML-KEM-768*: числове теоретичне перетворення (NTT) та модулярна арифметика у крейті `ml-kem` реалізовані без залежних від даних розгалужень. Деривація ключів HKDF та шифрування XSalsa20-Poly1305 є за визначенням рівночасовими через потоковий характер цих операцій.

### 5.3 Формальна верифікація

#### 5.3.1 Огляд та методологія верифікації

Протокол верифіковано двома незалежними символьними інструментами в моделі Dolev-Yao: ProVerif 2.05 [38] та Tamarin Prover 1.10.0 [39]. Верифікація охопила сім властивостей безпеки. Обидва інструменти використовують абстракцію DH, що є стандартним підходом для символьної верифікації [42, 43].

**Модель Dolev--Yao.** Символьна верифікація базується на моделі Dolev--Yao, в якій противник має *повний контроль над мережею*: може перехоплювати, затримувати, модифікувати, видаляти та повторно відтворювати будь-яке повідомлення. Криптографічні примітиви трактуються як ідеальні «чорні скриньки»: противник не може зламати шифрування без відповідного ключа, підробити MAC без ключа підпису або обернути односторонню функцію. Ця абстракція дозволяє зосередити аналіз на *логіці протоколу*, а не на конкретних криптографічних примітивах.

**Обґрунтування двоінструментальної верифікації.** ProVerif та Tamarin мають взаємодоповнюючі переваги [46]:
- *ProVerif* виконує автоматичну верифікацію для необмеженої кількості одночасних сесій, що гарантує відсутність атак на рівні багатосесійної взаємодії. Однак ProVerif може повертати хибні від'ємні результати (неможливість доведення) для складних властивостей зі станом.
- *Tamarin* використовує інтерактивне доведення з підтримкою довільних станових властивостей (пряма секретність, AND-модель). Tamarin є *звуковим* (sound) та *повним* (complete) для обмеженої кількості сесій, однак може не завершитися для необмежених сценаріїв.

Спільна верифікація обома інструментами усуває хибні підтвердження, що можуть виникати через специфічні абстракції кожного інструмента окремо. Аналогічний двоінструментальний підхід застосовано для верифікації TLS 1.3 у роботі Cremers et al. [46].

**Таблиця 5.1 --- Зведені результати формальної верифікації**

| # | Властивість | ProVerif | Tamarin | Rust-тести |
|---|---|---|---|---|
| P1 | Секретність сесійного ключа | **true** | **verified** (27 кроків) | 4 тести |
| P2 | Секретність пароля | **true** | **verified** (3 кроки) | 6 тестів |
| P3 | Класична пряма секретність | --- | **verified** (119 кроків) | 3 тести |
| P4 | Постквантова пряма секретність | --- | *випливає з P6* | 3 тести |
| P5a | Автентифікація ініціатора | **true** | **verified** (32 кроки) | 8 тестів |
| P5b | Автентифікація респондера | **true** | **verified** (17 кроків) | *(в P5a)* |
| P5c | Ін'єктивна взаємна автентифікація | **true** | *implied* | *(в P5a)* |
| P6 | AND-модель гібридної безпеки | --- | **verified** (29 кроків) | 4 тести |
| P7 | Стійкість до офлайн-перебору | --- | **verified** (4 кроки) | 6 тестів |
| --- | Коректність завершення (санітарна лема) | --- | **verified** (16 кроків) | 5 тестів за властивостями |
| **Разом** | | **5/5 підтверджено** | **8/8 доведено** | **126/126 пройдено** |

#### 5.3.2 ProVerif 2.05

**Інструмент:** ProVerif 2.05 (OCaml 5.4.0), macOS Darwin 25.2.0.
**Моделі:** `formal/hybrid_pq_opaque.pv` (секретність, 297 рядків), `formal/hybrid_pq_opaque_auth.pv` (автентифікація, 252 рядки).

**Рівняльна теорія.** Модель визначає три класи рівнянь, що моделюють відповідні криптографічні припущення:

1. *Комутативність DH:* $\texttt{ec\_dh}(a, \texttt{ec\_pk}(b)) = \texttt{ec\_dh}(b, \texttt{ec\_pk}(a))$ --- забезпечує, що клієнт та сервер обчислюють ідентичні значення $dh_1, \ldots, dh_4$ незалежно від порядку множення.
2. *Коректність KEM:* $\texttt{kem\_decaps}(sk, \texttt{kem\_encaps}(\texttt{kem\_pk}(sk), r)) = \texttt{kem\_shared}(\texttt{kem\_pk}(sk), r)$ --- моделює коректність декапсуляції ML-KEM-768.
3. *Фіналізація OPRF:* $\texttt{oprf\_finalize}(\texttt{oprf\_eval}(\texttt{oprf\_blind}(\text{pwd}, r), k), r, \text{pwd}) = \texttt{oprf\_output}(\text{pwd}, k)$ --- забезпечує відновлення виходу OPRF після розсліплення.

**Стратегія двох моделей.** Повна модель (`hybrid_pq_opaque.pv`) включає компрометацію довготривалого ключа сервера та необмежену реплікацію сесій (`!ClientAuth(...)`, `!ServerAuth(...)`), що дозволяє верифікувати властивості для довільної кількості одночасних сесій. Однак складність рівняльної теорії (зокрема, комутативність DH у поєднанні з подіями кореспонденції) спричиняє розбіжність ProVerif на запитах автентифікації. Тому запити автентифікації верифіковано в спрощеній моделі (`hybrid_pq_opaque_auth.pv`), де OPRF абстраговано до одноетапної функції $\texttt{oprf\_output}(\text{pwd}, k_{\text{oprf}})$. Ця двомодельна стратегія є стандартною методологією ProVerif-верифікації [46].

**Зв'язування ключа конверта.** Ключ шифрування конверта деривовано як $\texttt{envelope\_key\_derive}(\text{rwd}, pk_S)$, що *криптографічно зв'язує* конверт з конкретним сервером. Навіть якщо противник знає пароль, облікові дані не можуть бути перенесені між серверами, оскільки ключ залежить від $pk_S$.

P2 (секретність пароля) верифіковано в моделі з компрометацією LTK: `~pwd` є свіжим нонсом (`Fr(~pwd)`), що ніколи не потрапляє до `Out()`, тому противник не може його вивести. P1 (секретність сесійного ключа): навіть за компрометації LTK relay, ключ залежить від гібридного комбінування 4DH-ефемерних часток та $ss_{\text{kem}}$.

Запит P5c (ін'єктивна взаємна автентифікація):
```
query pkC: point, pkS: point, sk: key;
  inj-event(ServerCompletesAuth(pkS, pkC, sk))
  ==> inj-event(ClientCompletesAuth(pkC, pkS, sk)).
RESULT: true
```
Ін'єктивна відповідність один до одного запобігає атакам повторного відтворення повідомлень: кожне завершення сесії на стороні сервера має *рівно одне* відповідне завершення на стороні клієнта.

#### 5.3.3 Tamarin Prover 1.10.0

**Інструмент:** Tamarin 1.10.0 (Maude 3.4).
**Моделі:** повна модель `formal/hybrid_pq_opaque.spthy` (533 рядки) та верифікована модель `formal/hybrid_pq_opaque_verified.spthy` (193 рядки).
**Час верифікації:** 28,08 секунди (8 лем).

**Проблема вибуху простору станів.** Повна модель Tamarin використовує вбудовану теорію Діффі--Геллмана (`builtins: diffie-hellman`), що дозволяє символьне піднесення до степеня (`pk(x) = x^g`) та комутативність (`x^{a \cdot b} = x^{b \cdot a}`). Ця теорія спричиняє експоненційний вибух простору станів під час розв'язання обмежень: Tamarin повинен розглянути всі можливі ланцюги перезаписів DH-виразів. Верифікація однієї леми в повній моделі перевищувала 15 хвилин без завершення. Множинні евристики (`--heuristic=S`, `--heuristic=o`, `--auto-sources`) не забезпечили збіжності.

**Абстракція DH (звукова апроксимація).** Верифікована модель замінює вбудовану теорію DH абстрактною геш-функцією:
$$\texttt{dh\_secret} = h(\langle\text{``4dh''}, sk_C, sk_S, ek_C, ek_S\rangle)$$
Ця абстракція є *звуковою* (sound) у моделі Dolev--Yao [42]: спільний секрет DH є детерміністичною функцією приватних ключів, і здатність противника його обчислити визначається виключно подіями компрометації ключів. Правила корупції (`CorruptS`, `CorruptC`, `RevEphC`, `RevEphS`) точно моделюють розкриття окремих ключів. Будь-яка атака, виявлена в абстрактній моделі, була б дійсною і для конкретного DH-примітива; абстракція є *зверхньою* апроксимацією, що виключає хибні від'ємні результати.

**Модель корупції (5 правил).**

| Правило | Розкрита інформація | Мітка дії |
|---|---|---|
| `CorruptS` | Довготривалий ключ сервера $sk_S$ | `CLtk($S)` |
| `CorruptC` | Облікові дані клієнта $(sk_C, pk_C, \text{pwd})$ | `CLtk($C)` |
| `CorruptDB` | Реєстраційний запис (конверт, nonce, $pk_C$), *але не* OPRF-ключ `~ok` | `CDB($S, $C)` |
| `RevEphC` | Ефемерні ключі клієнта `~ek` та KEM-ключ `~ksk` | `RevEph($C)` |
| `RevEphS` | Ефемерні ключі сервера `~ekS` та KEM-рандом `~kr` | `RevEph($S)` |

Критичною деталлю є те, що `CorruptDB` *не розкриває* OPRF-ключ (`~ok`), оскільки він зберігається в окремому факті `!Oprf($S, $C, ~ok)`, відокремленому від реєстраційного запису `!Rec(...)`. Це моделює реалістичний сценарій: противник компрометує базу даних, але не пам'ять серверного процесу.

**Таблиця 5.2 --- Леми Tamarin**

| Лема | Кроки | Ключова властивість |
|---|---|---|
| `session_key_secrecy` (P1) | 27 | `!KU(~ek)` fails без `CorruptC` |
| `password_secrecy` (P2) | 3 | `~pwd` не потрапляє до `Out()` |
| `forward_secrecy` (P3) | 119 | Post-session LTK compromise, `~ek`/`~es` залишаються свіжими |
| `auth_initiator` (P5a) | 32 | MAC верифікація вимагає PRK; PRK --- від DH+KEM |
| `auth_responder` (P5b) | 17 | `KE3` MAC --- лише з `KE3` правила |
| `and_model` (P6) | 29 | Без ефемерних ключів неможливо обчислити 4DH і KEM ss одночасно |
| `dictionary_resistance` (P7) | 4 | Компрометація БД розкриває конверт, але не пароль і не OPRF-ключ |
| `completion` (коректність) | 16 | Існує трейс з успішним завершенням обох сторін |

**Лема P6 (AND-модель), детально:**
```
∀ C S sk #i. SKC(C, S, sk) @ #i
  ∧ ¬(∃ #j. RevEph(C) @ #j) ∧ ¬(∃ #j. RevEph(S) @ #j)
  ⟹ ¬(∃ #j. K(sk) @ #j)
Result: verified (29 steps)
```
Лема допускає компрометацію LTK (`CLtk` не обмежено), але забороняє розкриття ефемерних ключів. Навіть знаючи `skA` та `skR`, противник не може обчислити `combine(dh_secret, kem_ss)` без ефемерних `~ek` та `~ksk`. Це доводить AND-модель: необхідно подолати *обидва* шари одночасно.

**Лема P3 (119 кроків, пряма секретність):** Після компрометації довготривалих ключів (пост-сесійно) противник знає `skA`, `skR`, однак `~ek` та `~es` залишаються свіжими нонсами, що ніколи не передаються без правила `RevEph`. Всі 119 гілок розгалуження закриваються через `by solve(!KU(~ek))`.

**Структура доведення леми P3 (детальний розбір).** Tamarin починає з припущення, що противник знає сесійний ключ `sk`, та намагається побудувати ланцюг деривації від початкових знань противника. Оскільки `sk = kdf(combine(dh_secret, ..., kem_ss), tr)`, противник повинен знати `combine(...)`. Для обчислення `dh_secret = h(<'4dh', skC, skS, ekC, ekS>)` необхідно знати всі чотири приватних ключі. `skC` та `skS` відомі з подій `CLtk($C)` та `CLtk($S)` (пост-сесійна компрометація). Однак `~ek` (ефемерний ключ клієнта) та `~es` (ефемерний ключ сервера) є свіжими нонсами (`Fr(~ek)`, `Fr(~es)`), які передаються до мережі лише у вигляді `pk(~ek)` та `pk(~es)`. Оскільки `pk(·)` є одностороньою функцією в моделі Dolev--Yao, з `pk(~ek)` неможливо відновити `~ek`. Усі 119 гілок дерева доведення закриваються предикатом `!KU(~ek)` --- протиріччя, що підтверджує неможливість деривації ефемерного ключа. Аналогічно, `kem_ss = kem_decaps(~ksk, ct)` потребує `~ksk`, який також є свіжим нонсом без правила розкриття.

**Моделювання гібридного комбінатора.** Функція `combine(dh_secret, dh_secret, dh_secret, dh_secret, ks)` приймає п'ять аргументів. Чотири ідентичних аргументи `dh_secret` є наслідком абстракції: у повній моделі це були б чотири окремі значення $dh_1, \ldots, dh_4$, однак в абстрактній моделі всі залежать від того самого набору приватних ключів. П'ятий аргумент `ks` --- спільний секрет KEM. KDF `kdf(combine(...), tr)` додатково зв'язує сесійний ключ із транскриптом `tr`, запобігаючи повторному використанню ключів між сесіями.

**Лема P7 (стійкість до словникового перебирання, 4 кроки).** Лема допускає `CDB($S, $C)` (компрометація бази даних), яка розкриває конверт, nonce та $pk_C$, але *не* OPRF-ключ `~ok`. Без `~ok` противник не може обчислити $\texttt{argon2id}(\texttt{oprf}(\text{guess}, \texttt{\textasciitilde ok}), \text{guess})$ для жодного кандидата словника. Доведення закривається за 4 кроки, оскільки `~ok` зберігається лише у факті `!Oprf(...)`, який не має правила корупції.

#### 5.3.4 Матриця покриття верифікації

**Таблиця 5.3 --- Крос-інструментальне покриття**

| Властивість | ProVerif | Tamarin | Rust-тести |
|---|---|---|---|
| P1: Таємність сесійного ключа | доведено | доведено | 4 пройдено |
| P2: Таємність пароля | доведено | доведено | 6 пройдено |
| P3: Класична пряма секретність | --- | доведено | 3 пройдено |
| P4: Постквантова пряма секретність | --- | (через P6) | 3 пройдено |
| P5: Взаємна автентифікація | доведено (3 запити) | доведено (2 леми) | 8 пройдено |
| P6: AND-модель | --- | доведено | 4 пройдено |
| P7: Стійкість до словникового перебирання | --- | доведено | 6 пройдено |
| Коректність завершення | --- | доведено | 5 тестів за властивостями |

Розрив між символьною та обчислювальною моделями відображає загальновизнане обмеження формальної верифікації [42]: символьна верифікація абстрагує конкретні криптографічні примітиви, тоді як тести Rust перевіряють фактичну реалізацію на конкретних криптографічних значеннях. Поєднання обох підходів формує ієрархічну гарантію безпеки.

### 5.4 Розрив між символьною та обчислювальною моделями

Символьна (Dolev--Yao) верифікація трактує криптографічні примітиви як ідеальні «чорні скриньки» з алгебраїчними властивостями. Це створює розрив з реальними обчислювальними гарантіями, який є фундаментальним обмеженням будь-якої символьної верифікації [42, 46]. Нижче систематизовано джерела цього розриву та механізми його звуження.

**Обмеження символьної моделі.** Символьна верифікація *не охоплює*: (а) алгебраїчні співвідношення між різними DH-операціями (наприклад, атаки пакетної верифікації); (б) бічні канали на рівні реалізації (часові, кеш-атаки, електромагнітне випромінювання); (в) ненульову ймовірність відмови декапсуляції ML-KEM-768 ($\approx 2^{-164}$ [15]); (г) властивість memory-hard функції Argon2id --- обидва інструменти (ProVerif та Tamarin) моделюють Argon2id як односторонню функцію, не враховуючи вартість пам'яті при офлайн-переборі.

**Механізми звуження розриву.** Три рівні верифікації взаємно доповнюють один одного:

1. *Символьна верифікація (Tamarin/ProVerif)*: доводить структурну коректність протоколу --- відсутність атак на рівні потоку повідомлень, деривації ключів та транскрипту. Це найвищий рівень абстракції.
2. *Редукційні доведення (Теореми 1--5)*: зв'язують безпеку протоколу з обчислювальними припущеннями (CDH, Module-LWE, PRF). Кожна теорема формулює верхню межу переваги противника через перевагу зламу конкретного примітива.
3. *Тести Rust-реалізації (126 сценаріїв)*: перевіряють конкретні криптографічні значення на реальних примітивах (libsodium, `ml-kem`). Тести на основі властивостей (`proptest`) генерують довільні вхідні дані та перевіряють інваріанти безпеки для будь-яких допустимих значень.

**Залишковий розрив.** Повне усунення розриву між моделями є неможливим [42]. Основні залишкові ризики: (а) помилки реалізації у бібліотеках libsodium або `ml-kem`, не виявлені тестуванням на основі властивостей; (б) апаратні бічні канали (аналіз енергоспоживання, електромагнітне випромінювання), що виходять за межі програмної моделі загроз; (в) невідповідність між абстрактними специфікаціями примітивів та їх конкретними реалізаціями. Обчислювальна звукість (computational soundness) результатів базується на припущенні, що конкретні примітиви відповідають своїм абстрактним специфікаціям --- стандартне припущення в галузі формальної верифікації протоколів безпеки.

---

## 6. РЕАЛІЗАЦІЯ ТА ЕКСПЕРИМЕНТАЛЬНА ОЦІНКА

### 6.1 Архітектура Rust-реалізації

Протокол Гібридного PQ-OPAQUE реалізовано мовою програмування **Rust 1.93.1** у вигляді багатокрейтного простору проєктів. Вибір Rust обумовлений кількома чинниками.

*Безпека пам'яті на рівні компілятора.* Система типів Rust та інспектор запозичень (borrow checker) статично гарантують відсутність: використання після звільнення (use-after-free), подвійного звільнення (double free), перегонів даних (data races) та нульових покажчиків. У контексті криптографічного програмного забезпечення ці гарантії є критично важливими: помилки управління пам'яттю у C/C++ є основним джерелом вразливостей у криптографічних бібліотеках (за даними Microsoft Security Response Center, $\approx 70\%$ CVE пов'язані з порушеннями безпеки пам'яті).

*Директива `#![forbid(unsafe_code)]`.* Крейти `opaque-core`, `opaque-agent` та `opaque-relay` позначені директивою `#![forbid(unsafe_code)]`, що забороняє використання небезпечних конструкцій Rust у будь-якій частині коду. Єдиним крейтом, що використовує `unsafe` --- це `opaque-ffi`, де FFI-виклики до libsodium потребують `extern "C"` та роботи з сирими покажчиками. Весь `unsafe`-код у `opaque-ffi` ізольований та задокументований з обґрунтуванням безпеки (SAFETY-коментарі).

*Екосистема криптографічних бібліотек.* Rust забезпечує ергономічну інтеграцію з `libsodium-sys-stable` (системні прив'язки до libsodium) та `ml-kem` (чиста Rust-реалізація ML-KEM-768 без зовнішніх залежностей). Трейт `zeroize::Zeroize` забезпечує безпечне затирання ключів у пам'яті через бар'єри оптимізації.

**Таблиця 6.1 --- Метрики вихідного коду простору проєктів**

| Крейт | Призначення | РВК (src) | Залежності |
|---|---|---|---|
| `opaque-core` | Криптографічні примітиви | 1675 | libsodium-sys-stable, ml-kem |
| `opaque-agent` | Ініціатор (клієнт) | 611 | opaque-core |
| `opaque-relay` | Респондер (сервер) | 593 | opaque-core |
| `opaque-ffi` | Прошарок інтерфейсу зовнішніх функцій | 870 | opaque-agent, opaque-relay |
| **Разом (виробничий код)** | | **3749** | |
| Тести | | 2731 | proptest, criterion |
| Еталонні вимірювання | | 1200 | criterion |
| Формальні моделі (.spthy + .pv) | | 1806 | Tamarin, ProVerif |

**Залежності від зовнішніх бібліотек.** Реалізація мінімізує ланцюг залежностей: `libsodium-sys-stable` (1.0.21) --- системні прив'язки до libsodium без додаткових обгорток; `ml-kem` (0.3.0) --- чиста Rust-реалізація ML-KEM без `unsafe`-коду та зовнішніх C-залежностей; `zeroize` (1.8) --- гарантоване затирання пам'яті.
Відсутність залежностей від OpenSSL, BoringSSL або ring спрощує крос-компіляцію та аудит безпеки.

**Структура `opaque-core`** (1675 рядків коду):
- `crypto.rs` (622): DH Ristretto255, HKDF-Extract/Expand, HMAC-SHA-512, XSalsa20-Poly1305, `zeroize`;
- `pq_kem.rs` (149): обгортка ML-KEM-768 + гібридний комбінатор `combine_key_material`;
- `types.rs` (321): типи-обгортки для всіх криптографічних значень із автоматичним затиранням при знищенні (`zeroize on Drop`);
- `protocol.rs` (268): серіалізація/десеріалізація дротового формату;
- `envelope.rs` (149): запечатування/відкриття конверту (XSalsa20-Poly1305);
- `oprf.rs` (134): забутлива псевдовипадкова функція;

**Ключові конструктивні рішення:**
- *Синтаксичний аналіз без копіювання*: функції `parse_ke1()`, `parse_ke2()`, `parse_ke3()` повертають зрізи `&[u8]` без виділення додаткової пам'яті;
- *Автоматичне затирання при знищенні*: всі структури, що містять чутливі дані (`SessionKey`, `MasterKey`, `SharedSecret`), реалізують `zeroize::Zeroize` та автоматично затирають пам'ять при виході зі сфери видимості;
- *Рівночасові порівняння*: усі порівняння кодів автентифікації повідомлень здійснюються через `sodium_memcmp` бібліотеки libsodium;
- *Граничне перевіряння на вході*: кожна функція перевіряє довжину буферів, ненульовість скалярів та приналежність точок до групи Ristretto255 ще до початку криптографічних обчислень.

### 6.2 Архітектура безпеки пам'яті

Криптографічні реалізації вимагають гарантій знищення ключового матеріалу в пам'яті після використання. Мова Rust забезпечує *автоматичне* управління часом життя об'єктів через систему володіння (ownership), однак знищення за замовчуванням (виклик `drop`) не гарантує затирання пам'яті: компілятор може оптимізувати запис нулів як «мертвий код» [36]. Реалізація використовує бібліотеку `zeroize` (версія 1.8), що забезпечує *гарантоване* затирання через бар'єри оптимізації.

**Стратегія автоматичного затирання.** Усі типи, що містять чутливі дані, реалізують трейти `Zeroize` та `ZeroizeOnDrop`:

**Таблиця 6.1a --- Типи з автоматичним затиранням при знищенні**

| Тип | Вміст | Механізм |
|---|---|---|
| `SecureBytes` | `Vec<u8>` довільної довжини | `ZeroizeOnDrop` + `Debug` → `[REDACTED; N]` |
| `SessionKey` | 64 байти сесійного ключа | `ZeroizeOnDrop` |
| `MasterKey` | 32 байти майстер-ключа | `ZeroizeOnDrop` |
| `SharedSecret` | 32 байти спільного секрету KEM | `ZeroizeOnDrop` |
| `Envelope` | nonce (24 б) + ciphertext (96 б) + auth\_tag (16 б) | `ZeroizeOnDrop` |
| `InitiatorState` | ефемерні ключі, OPRF-скаляр, стан сесії | `ZeroizeOnDrop` |
| `ResponderState` | ефемерний ключ DH, спільний секрет KEM, MAC | `ZeroizeOnDrop` |

**Ручне затирання локальних масивів.** У функціях, де чутливі дані створюються як локальні змінні (не структури зі `ZeroizeOnDrop`), затирання виконується явно перед поверненням:
- `combine_key_material()`: масиви `combined_ikm` (160 б) та `labeled_transcript` затираються після обчислення PRK;
- `seal()` (конверт): `auth_key` та відкритий текст затираються після шифрування;
- `derive_oprf_key()`: проміжні значення `mac`, `oprf_seed` та `input` затираються після деривації OPRF-ключа.

**Затирання при помилках.** Якщо верифікація MAC у функції `open()` (конверт) завершується невдачею, розшифрований відкритий текст затирається *перед* поверненням помилки. Аналогічно, у функції `responder_finish()`, при невдалій верифікації MAC ініціатора, всі сесійні ключі, спільний секрет KEM та очікуваний MAC затираються до повернення `AuthenticationError`.

**Захист від журналювання.** Реалізація `Debug` для типу `SecureBytes` виводить `SecureBytes([REDACTED; N])`, де `N` --- довжина вектора. Це запобігає випадковому потраплянню ключового матеріалу до журналів діагностики.

### 6.3 Архітектура прошарку інтерфейсу зовнішніх функцій (FFI)

Крейт `opaque-ffi` (870 рядків виробничого коду) забезпечує C-сумісний API для інтеграції протоколу в середовища C, C#, Android та інші платформи, що підтримують зовнішній виклик функцій (FFI).

**Шаблон непрозорих маніпуляторів (handle pattern).** FFI-шар використовує непрозорі маніпулятори для управління часом життя Rust-структур у коді мовою C: функція `opaque_agent_create()` виділяє `Box<AgentHandle>` та повертає непрозорий покажчик `*mut c_void`; функція `opaque_agent_destroy()` повертає маніпулятор та знищує його, автоматично викликаючи `ZeroizeOnDrop` для всіх внутрішніх структур. Цей шаблон запобігає прямому доступу C-коду до Rust-пам'яті.

**Коди помилок.** Перелічення `OpaqueError` визначає 9 варіантів помилок, що відображаються на від'ємні цілі числа за конвенцією POSIX:

| Код | Варіант | Опис |
|---|---|---|
| -1 | `InvalidInput` | Некоректні вхідні параметри |
| -2 | `CryptoError` | Помилка криптографічної операції |
| -3 | `InvalidProtocolMessage` | Порушення формату повідомлення |
| -4 | `ValidationError` | Помилка валідації |
| -5 | `AuthenticationError` | Невдала автентифікація (невірний MAC) |
| -6 | `InvalidPublicKey` | Неканонічний або тотожний відкритий ключ |
| -7 | `AlreadyRegistered` | Обліковий запис вже існує |
| -8 | `InvalidKemInput` | Некоректні параметри ML-KEM |
| -9 | `InvalidEnvelope` | Порушення цілісності конверта |

Нульове значення (0) сигналізує успіх. Кожна FFI-функція виконує валідацію вхідних параметрів (перевірка нульових покажчиків, довжин буферів, передумов стану) *перед* зверненням до внутрішніх Rust-функцій.

### 6.4 Тестова база та методологія верифікації коректності реалізації

Набір тестів будується за принципом відповідності тестових модулів властивостям безпеки, встановленим у Розділі 3. Кожна властивість $P_i$ верифікується незалежно у двох вимірах: (а) у символьній моделі (ProVerif/Tamarin) та (б) через конкретні криптографічні значення в Rust-реалізації. Такий дворівневий підхід усуває розрив між абстрактними доведеннями та фактичним виконуваним кодом.

Тестування поділяється на три методологічні класи:
- *Детерміністичні тести* перевіряють конкретні протокольні сценарії з фіксованими або псевдовипадковими вхідними даними (перевірка коректності, перевірка від'ємних випадків);
- *Інтеграційні тести* виконують повний наскрізний цикл реєстрація $\to$ автентифікація та перевіряють збіжність ключів на обох сторонах;
- *Тести на основі властивостей* (бібліотека `proptest`) генерують довільні вхідні дані за визначеними стратегіями і перевіряють інваріанти безпеки для будь-яких допустимих вхідних значень; цей підхід відповідає частковому обґрунтуванню коректності реалізації методом структурованого нечіткого тестування.

**Таблиця 6.2 --- Розподіл тестів за властивостями безпеки**

| Модуль тестів | Властивість | Кількість | Методологічний клас |
|---|---|---|---|
| `p1_session_key_secrecy` | P1: таємність сесійного ключа | 4 | Детерміністичний |
| `p2_password_secrecy` | P2: таємність пароля | 6 | Детерміністичний |
| `p3_classical_forward_secrecy` | P3: класична пряма секретність | 3 | Детерміністичний |
| `p4_pq_forward_secrecy` | P4: постквантова пряма секретність | 3 | Детерміністичний |
| `p5_mutual_authentication` | P5: взаємна автентифікація | 8 | Детерміністичний |
| `p6_and_model_hybrid_security` | P6: AND-модель гібридної безпеки | 4 | Детерміністичний |
| `p7_offline_dictionary_resistance` | P7: стійкість до словникового перебирання | 6 | Детерміністичний |
| `integration` | Наскрізний цикл: реєстрація + автентифікація | 7 | Інтеграційний |
| `security_proptest` | P1, P2, P5 (довільні вхідні дані) | 5 | На основі властивостей |
| `crypto_tests` | Криптографічні примітиви | 28 | Модульний |
| `envelope_tests` | Конверт | 6 | Модульний |
| `oprf_tests` | OPRF | 12 | Модульний |
| `pq_kem_tests` | ML-KEM-768 | 8 | Модульний |
| `protocol_tests` | Серіалізація/десеріалізація | 11 | Модульний |
| `server_tests` | Рівень респондера | 15 | Модульний |
| **Разом** | | **126 сценаріїв** | **0 відмов** |

```
test result: ok. 126 passed; 0 failed; 0 ignored
(Apple M1 Pro, Rust 1.93.1, режим діагностичного складання)
```

**Методологічний коментар.** Модулі `p3_classical_forward_secrecy` та `p4_pq_forward_secrecy` перевіряють, що після завершення сесії та знищення ефемерних ключів ($e_C$, $e_S$, $sk_{\text{kem}}$) жодна із збережених сторін не може відновити $K_s$ навіть при наявності довготривалих ключів $sk_C$, $sk_S$. Модуль `p6_and_model_hybrid_security` підтверджує: незалежний збій будь-якого з двох криптографічних шарів (DH або ML-KEM-768) не призводить до розкриття сесійного ключа.

**Тестування на основі властивостей (детальний опис).** Модуль `security_proptest` використовує бібліотеку `proptest` для генерації довільних вхідних даних за визначеними стратегіями. П'ять тестових сценаріїв перевіряють такі інваріанти:

1. *Паролі довільної довжини* --- стратегія генерує паролі від порожнього рядка до максимальної довжини (256 символів), включаючи Unicode-символи та спеціальні символи. Інваріант: реєстрація та автентифікація успішно завершуються для будь-якого допустимого пароля.
2. *Ізоляція сесій* --- для кожної пари (пароль, ідентифікатор облікового запису) дві послідовні сесії генерують *різні* сесійні ключі. Інваріант: $K_s^{(1)} \neq K_s^{(2)}$ для всіх пар сесій.
3. *Мутаційне тестування повідомлень* --- довільний байт у повідомленні KE2 модифікується (побітове інвертування); інваріант: автентифікація *завжди* завершується помилкою при мутації.
4. *Збіжність ключів* --- для довільних вхідних даних клієнтський та серверний сесійні ключі завжди збігаються: $K_s^{C} = K_s^{S}$ та $K_m^{C} = K_m^{S}$.
5. *Невідновлюваність пароля* --- з перехоплених повідомлень KE1, KE2, KE3 та реєстраційного запису неможливо реконструювати пароль (перевіряється відсутність детерміністичного зв'язку між паролем та спостережуваними значеннями).

**Тестування від'ємних випадків (adversarial testing).** Окремі тести перевіряють коректне відхилення некоректних вхідних даних:
- Порожній пароль при реєстрації → помилка `InvalidInput`;
- Спотворений KE2 (модифікований MAC) → помилка `AuthenticationError`;
- Невірний пароль при автентифікації → помилка `AuthenticationError` (рівночасова перевірка);
- Неканонічна точка Ristretto255 → помилка `InvalidPublicKey`;
- KE1 із некоректною довжиною → помилка `InvalidProtocolMessage`.

### 6.5 Методологія еталонних вимірювань продуктивності

**Апаратна платформа:** Apple M1 Pro (8 високопродуктивних + 2 енергоефективних ядра, 16 ГБ LPDDR5, частота: 3,228 ГГц), macOS 26.2 (Darwin 25.2.0), Rust 1.93.1.

**Фреймворк вимірювань:** Criterion 0.5.1 --- статистичний фреймворк еталонних вимірювань для Rust. Фреймворк Criterion застосовує метод бутстрапу Welch для побудови довірчих інтервалів: для кожної операції виконується $N_s = 100$ незалежних вибірок, кожна з яких є вибірковим середнім $\overline{t}_i$ по заданій кількості ітерацій $n_i$; ітерації підбираються автоматично до досягнення відносної похибки $\epsilon < 0{,}01$. Вибіркове середнє вимірювань $\hat{\mu}$ та 95-відсотковий довірчий інтервал (ДІ) отримуються методом бутстрапу з 100\,000 перевибірок. Фаза прогріву тривалістю 3 с передує власне вимірюванням для термалізації процесора та заповнення кешів.

**Умови вимірювань:** режим оптимізованого складання (`--release`, `opt-level = 3`, `lto = false`); детермінований однопотоковий запуск для виключення впливу паралелізму. Для мінімізації впливу системних процесів кожне вимірювання виконувалося з закритими фоновими додатками. Вимірювання проводилися при температурі процесора в стаціонарному режимі (після фази прогріву), що виключає теплове гальмування (thermal throttling) як джерело систематичної похибки.

**Контроль статистичної якості.** Criterion автоматично виявляє аномалії (outliers) через MAD-метод (Median Absolute Deviation) та класифікує їх як: *помірні* ($|x - \tilde{x}| > 3 \cdot \text{MAD}$) та *серйозні* ($|x - \tilde{x}| > 10 \cdot \text{MAD}$). Для кожного вимірювання фіксується частка аномалій; у наших результатах частка серйозних аномалій не перевищувала 2%, що підтверджує стабільність вимірювального середовища.

**Позначення:** усі результати подаються у форматі «вибіркове середнє $\hat{\mu}$; 95\% ДІ $[\hat{\mu}_L;\, \hat{\mu}_H]$»; одиниці --- мікросекунди (мкс) для операцій криптографічного рівня та мілісекунди (мс) для Argon2id.

### 6.6 Еталонні вимірювання криптографічних примітивів

**Таблиця 6.3 --- Еталонні вимірювання криптографічних примітивів (Apple M1 Pro, Rust 1.93.1, `cargo bench --release`)**

| Примітив | Операція | $\hat{\mu}$ | 95% ДІ |
|---|---|---|---|
| Ristretto255 | Генерація ключової пари | 16,74 мкс | [16,03; 17,84] |
| Ristretto255 | Одиничне скалярне множення (DH) | 46,41 мкс | [45,94; 46,98] |
| Ristretto255 | Потрійне скалярне множення (3DH, еталон) | 119,04 мкс | [117,10; 122,14] |
| Ristretto255 | **Четверне скалярне множення (4DH, протокол)** | **$\approx$ 164 мкс** | [$\approx$162; $\approx$167] |
| ML-KEM-768 | Генерація ключової пари | 41,05 мкс | [40,69; 41,68] |
| ML-KEM-768 | Інкапсуляція | 33,62 мкс | [32,89; 34,95] |
| ML-KEM-768 | Декапсуляція | 38,55 мкс | [37,65; 40,11] |
| ML-KEM-768 | **Повний раунд (ГКП + Інк + Дек)** | **122,01 мкс** | [119,32; 126,96] |
| OPRF | Засліплення вхідного значення | 56,16 мкс | [54,37; 59,36] |
| OPRF | Обчислення серверного відгуку | 47,59 мкс | [44,97; 52,45] |
| OPRF | Фіналізація клієнтом | 65,68 мкс | [64,17; 67,89] |
| HKDF | Витяг (HMAC-SHA-512) | 1,32 мкс | [1,312; 1,319] |
| HKDF | Розширення (вихід 64 байти) | 1,21 мкс | [1,181; 1,245] |
| HMAC-SHA-512 | Вхід 256 байт | 1,61 мкс | [1,596; 1,641] |
| XSalsa20-Poly1305 | Шифрування (96 байт) | 440,79 нс | [430,20; 459,46] |
| XSalsa20-Poly1305 | Розшифрування (96 байт) | 613,42 нс | [594,15; 636,12] |
| Argon2id | **Параметри MODERATE** | **510,86 мс** | [490,31; 533,80] |
| Гібридний комбінатор | HKDF-Extract (класичний 128 + KEM 32 = 160 байт) | 1,48 мкс | [1,453; 1,508] |

**Аналітичні спостереження.** Дані таблиці дозволяють зробити три ключові висновки:

(1) *Порівнянна вартість класичного та постквантового шарів.* Повний раунд ML-KEM-768 ($\hat{\mu} = 122$ мкс, 95% ДІ [119,32; 126,96]) та четверне скалярне множення Ristretto255 ($\hat{\mu} \approx 164$ мкс) мають близькі порядки величин. Відношення постквантових до класичних накладних витрат CPU становить лише $\times 1{,}06$, тобто інтеграція ML-KEM-768 не змінює асимптотичного класу складності протоколу.

(2) *Абсолютне домінування функції жорсткого перетворення пароля.* Argon2id із параметрами MODERATE ($\hat{\mu} = 510{,}86$ мс, 95% ДІ [490,31; 533,80]) перевищує повний раунд ML-KEM-768 у $4\,175$ разів. Ця диспропорція є свідомим проєктним рішенням: висока обчислювальна вартість Argon2id забезпечує практичну непридатність офлайн-перебирання словника.

(3) *Практична безвартісність гібридного комбінатора.* Функція $\texttt{combine\_key\_material}$ ($\hat{\mu} = 1{,}48$ мкс) вносить менше 0,001% у загальний наскрізний час виконання, підтверджуючи ефективність конструкції HKDF-Extract для об'єднання різнорідних джерел ключового матеріалу.

### 6.7 Еталонні вимірювання рівня протоколу

**Таблиця 6.4 --- Еталонні вимірювання протокольних функцій**

| Фаза | Функція | $\hat{\mu}$ | 95% ДІ | Домінуючий компонент |
|---|---|---|---|---|
| Реєстрація | `create_request` | 72,46 мкс | [72,15; 72,77] | Засліплення OPRF |
| Реєстрація | `create_response` | 45,92 мкс | [45,72; 46,16] | Обчислення OPRF |
| Реєстрація | `finalize` | **479,58 мс** | [472,11; 487,75] | **Argon2id** |
| Автентифікація | `generate_ke1` | 118,83 мкс | [116,59; 121,76] | Засліплення OPRF + генерація ключів ML-KEM-768 |
| Автентифікація | `generate_ke2` | 297,03 мкс | [294,81; 299,69] | 4DH + інкапсуляція ML-KEM-768 |
| Автентифікація | `generate_ke3` | **492,34 мс** | [478,95; 509,96] | **Argon2id** + декапсуляція ML-KEM-768 |
| Автентифікація | `responder_finish` | 1,24 мкс | [1,174; 1,323] | Перевірка коду автентифікації |
| Повний протокол | `authentication_e2e` | **481,43 мс** | [471,73; 495,25] | **Argon2id** (99,8%) |

**Аналіз домінування функції жорсткого перетворення пароля.** Argon2id (510 мс) займає 99,8% часу повного наскрізного циклу. Сукупні постквантові операції (генерація ключів + інкапсуляція + декапсуляція ML-KEM-768 $= 122$ мкс) складають лише 0,023% загального часу. Цей результат є фундаментальним підтвердженням того, що постквантові накладні витрати CPU є практично нульовими у протоколі, де функція жорсткого перетворення пароля є архітектурно необхідним компонентом захисту від атак офлайн-перебирання.

**Аналіз функції $\texttt{generate\_ke2} = 297$ мкс.** Час виконання розкладається на: четверне скалярне множення Ristretto255 ($\approx 164$ мкс) + інкапсуляція ML-KEM-768 ($\approx 34$ мкс) + деривація ключів HKDF-Expand ($\approx 6$ мкс) + обчислення MAC ($\approx 2$ мкс) + операційні витрати $\approx 91$ мкс. Четвертий скалярний добуток $dh_4 = e_S \cdot E_C$ забезпечує стійкість до атаки підміни ключа (UKS) і пояснює зростання часу порівняно з тристоронньою схемою DH приблизно на 41 мкс.

**Аналіз асиметрії клієнт/сервер.** Функція `generate_ke3` ($\hat{\mu} = 492$ мс) домінується Argon2id ($\approx 510$ мс), що виконується на стороні *ініціатора*. Респондер не виконує Argon2id, тому `generate_ke2` ($\hat{\mu} = 297$ мкс) у $\approx 1{,}660$ разів швидший за `generate_ke3`. Ця асиметрія є *свідомою*: обчислювальне навантаження Argon2id покладено на клієнта, оскільки саме клієнт зберігає пароль. Сервер виконує лише асиметричні криптографічні операції (4DH + KEM), що забезпечує його високу пропускну здатність.

### 6.8 Аналіз пропускної здатності респондера

**Таблиця 6.5 --- Пропускна здатність вузла-респондера**

| Сценарій | $\hat{\mu}$ | Пропускна здатність |
|---|---|---|
| `ke2_and_finish` (респондер, без Argon2id) | 760,82 нс | **1,31 млн авт./с** |
| `ke2_only` (респондер, без Argon2id) | 254,26 мкс | 3,93 тис. авт./с |

Сценарій `ke2_and_finish` вимірює фінальну фазу серверної обробки: верифікацію коду автентифікації ініціатора та витяг сесійного ключа (функція `responder_finish`). Фаза генерації KE2 (4DH + інкапсуляція ML-KEM-768 + деривація ключів HKDF) виконується у фазі налаштування бенчмарку і виміряна окремо у сценарії `ke2_only`. Вузол-респондер не виконує Argon2id (цю операцію здійснює лише ініціатор на своєму боці), тому теоретична пропускна здатність на одному ядрі Apple M1 Pro становить 1,31 мільйона автентифікацій на секунду. У реальному розгортанні з мережевими затримками та операціями введення-виведення пропускна здатність обмежуватиметься мережевою латентністю, а не обчислювальними ресурсами процесора, що підтверджує відсутність вузького місця на стороні сервера.

### 6.9 Кількісна оцінка накладних витрат постквантового компонента: класична схема проти гібридної

Для ізоляції та кількісної оцінки обчислювальної вартості механізму інкапсуляції ключів ML-KEM-768 розроблено спеціалізований модуль еталонних вимірювань `bench_pq_overhead`. Він порівнює дві конфігурації: **класичний OPAQUE** (лише 4DH, без ML-KEM-768) та **Гібридний PQ-OPAQUE** (4DH + ML-KEM-768) на рівні кожної фази ключового обміну. Функцію жорсткого перетворення пароля Argon2id навмисно виключено для ізоляції накладних витрат асиметричних криптографічних операцій. Вимірювання проведено на Apple M1 Pro, обсяг вибірки 100, тривалість прогріву 3 с.

**Таблиця 6.6 --- Накладні витрати ML-KEM-768 по фазах ключового обміну (без Argon2id)**

| Фаза AKE | Класична (4DH) | Гібридна (4DH+KEM) | Абс. надлишок | Відн. надлишок | Постквантова операція |
|---|---|---|---|---|---|
| KE1 (ініціатор) | 73,2 мкс | 114,5 мкс | **+41,3 мкс** | +56,4% | Генерація ключів ML-KEM-768 |
| KE2 (респондер, без KSF) | 219,0 мкс | 239,5 мкс | **+20,4 мкс** | +9,3% | Інкапсуляція + комбінатор |
| KE3 (ініціатор, без KSF) | 234,0 мкс | 267,6 мкс | **+33,2 мкс** | +14,2% | Декапсуляція + комбінатор |
| **Повний AKE (без KSF)** | **528,2 мкс** | **687,5 мкс** | **+159,3 мкс** | **+30,1%** | Ген. кл. + інкапс. + декапс. |

**Примітка до KE3.** Власний вимірюваний надлишок декапсуляції ML-KEM-768 ($\approx 33$ мкс) підтверджується мікровимірюванням (`decapsulate`, $\hat{\mu} = 38{,}55$ мкс); рештою спостережуваного надлишку пояснюється фіналізацією OPRF ($\approx 66$ мкс) та варіативністю кешу процесора.

**Кількісний аналіз постквантових накладних витрат.** Сукупний надлишок CPU у повному раунді ключового обміну без KSF складає $\Delta_{PQ} = +159{,}3$ мкс. Розкладання за операціями:
$$\Delta_{PQ} \approx \underbrace{41{,}4}_{\text{ген. кл.}} + \underbrace{33{,}8}_{\text{інкапс.}} + \underbrace{39{,}2}_{\text{декапс.}} + \underbrace{2 \times 1{,}48}_{\text{комб.}} + \underbrace{\delta_{\text{алок.}}}_{{\approx}42} \approx 119{,}3 + 42 = 161\text{ мкс},$$
де $\delta_{\text{алок.}}$ --- витрати алокації буферів ключів ML-KEM-768: $|pk_{\text{kem}}| \approx 1{,}2$ КБ, $|sk_{\text{kem}}| \approx 2{,}4$ КБ, $|ct_{\text{kem}}| \approx 1{,}1$ КБ. Порівняно з Argon2id ($\hat{\mu} = 510{,}86$ мс), постквантовий надлишок складає $0{,}031\%$ від реального наскрізного часу.

**Висновок.** Ціна квантової стійкості протоколу --- 159 мкс чистого часу CPU на повний раунд ключового обміну (на 4DH-базисі), що є практично непомітним накладним навантаженням у будь-якому реалістичному сценарії застосування.

### 6.10 Порівняльний аналіз гібридних протоколів захищеного з'єднання

**Таблиця 6.7 --- Порівняння гібридних постквантових протоколів**

| Властивість | TLS 1.3 Hybrid | Signal PQXDH | WireGuard PQ | **Гібридний PQ-OPAQUE** |
|---|---|---|---|---|
| Класична основа | ECDH (X25519) | X3DH (X25519) | Noise IK (X25519) | **4DH (Ristretto255)** |
| Постквантовий компонент | ML-KEM-768 | ML-KEM-1024 | ML-KEM-768 | **ML-KEM-768** |
| AND-модель безпеки | Так | Так | Так | **Так** |
| Тип автентифікації | PKI-сертифікати | Пакет попередніх ключів | Статичні ключі | **PAKE (OPRF + пароль)** |
| Захист від компрометації сервера | Ні | Ні | Ні | **Так (aPAKE)** |
| Захист від офлайн-перебирання | Ні | Ні | Ні | **Так (Argon2id)** |
| Пряма секретність (класична) | Так | Так | Ні | **Так** |
| Постквантова пряма секретність | Так | Так | Ні | **Так** |
| Формальна верифікація | TLS 1.3 | --- | --- | **ProVerif + Tamarin** |
| Обсяг рукостискання | $\approx$3200 байт | $\approx$2400 байт | $\approx$2800 байт | **2712 байт** |
| Кількість раундів обміну | 1 RTT | 0 RTT (асинхронний) | 1 RTT | **1,5 RTT** |

Гібридний PQ-OPAQUE є єдиним протоколом у наведеному порівнянні, що забезпечує *одночасно* захист пароля від компрометації сервера та захист від офлайн-атак перебирання. Додаткова вартість --- 0,5 RTT порівняно з TLS 1.3 Hybrid. Обсяг рукостискання (2712 байт) є найменшим серед розглянутих PQ-протоколів, що інтегрують компоненти ML-KEM-768 (1184 + 1088 = 2272 байти накладних витрат на передавання).

**Порівняння моделей безпеки.** TLS 1.3 Hybrid, Signal PQXDH та WireGuard PQ спираються на попередньо розповсюджені відкриті ключі (PKI-сертифікати, пакети попередніх ключів, статичні ключі відповідно). Компрометація серверного сховища в цих протоколах призводить до *повної* компрометації довіри: противник, що отримав серверний приватний ключ, може видавати себе за сервер у всіх майбутніх сесіях. Гібридний PQ-OPAQUE, завдяки конструкції aPAKE, забезпечує *двофакторний* захист: компрометація серверного сховища (конверту) *без* знання пароля не дозволяє відновити облікові дані клієнта.

**Порівняння глибини формальної верифікації.** TLS 1.3 має найглибшу верифікацію [46] серед порівнюваних протоколів, однак його постквантове розширення [18] *не верифіковане* окремо. Signal PQXDH [19] має обчислювальне доведення безпеки, але *без* символьної верифікації. WireGuard PQ [20] верифікований лише для класичного Noise IK. Гібридний PQ-OPAQUE верифіковано двома інструментами саме для *гібридної* конструкції, включаючи AND-модель --- властивість, відсутню у формальних аналізах інших розглянутих протоколів.

### 6.11 Формальні моделі верифікації

**Таблиця 6.8 --- Метрики формальних верифікаційних моделей**

| Файл | Інструмент | РВК | Призначення |
|---|---|---|---|
| `hybrid_pq_opaque.spthy` | Tamarin | 533 | Повна модель (не верифікується через вичерпання часу) |
| `hybrid_pq_opaque_ascii.spthy` | Tamarin | 533 | ASCII-варіант для зовнішнього огляду |
| `hybrid_pq_opaque_verified.spthy` | Tamarin | 193 | Верифікована модель (абстрактний DH) |
| `hybrid_pq_opaque.pv` | ProVerif | 296 | Таємність ключа та пароля |
| `hybrid_pq_opaque_auth.pv` | ProVerif | 251 | Взаємна автентифікація |
| **Разом** | | **1806** | |

### 6.12 Вхідна валідація та захист від некоректних криптографічних значень

Кожна функція, що приймає криптографічні значення ззовні (від мережі або через FFI), виконує каскад перевірок *перед* початком обчислень. Ця стратегія «раннього відхилення» (fail-fast) мінімізує поверхню атаки, запобігаючи обробці потенційно шкідливих вхідних даних.

**Валідація точок Ristretto255.** Функція `validate_ristretto_point` виконує три послідовних перевірки: (1) довжина входу рівно 32 байти; (2) точка не є елементом тотожності (перевірка `sodium_is_zero`); (3) канонічне кодування є дійсним елементом групи Ristretto255 (`crypto_core_ristretto255_is_valid_point`). Відхилення неканонічних кодувань запобігає атакам малих підгруп та атакам на основі ковких (malleable) кодувань.

**Забезпечення ненульовості скалярів.** Генерація випадкового ненульового скаляра `random_nonzero_scalar` використовує циклічну перевірку: після генерації 32 випадкових байт виконується перевірка на нуль. Імовірність повторної генерації дорівнює $1/q \approx 2^{-252}$, тобто практично перша ітерація завжди успішна. Функція `derive_oprf_key` використовує інший підхід --- лічильний метод (try-and-increment): послідовно обчислюється $\text{HMAC}(\text{oprf\_seed}, \text{``OPRF-Key''} \| \text{account\_id} \| \text{counter})$ для counter $\in \{0, 1, \ldots, 254\}$, поки результат після скалярної редукції за модулем $q$ не стане ненульовим. Максимум 255 спроб гарантує завершення.

**Валідація ML-KEM-768.** Функції `encapsulate` та `decapsulate` перевіряють розміри буферів (відкритий ключ = 1184 байти, шифротекст = 1088 байт, спільний секрет = 32 байти) *перед* зверненням до криптографічних операцій. Внутрішня функція `EK::from_bytes` крейту `ml-kem` додатково виконує декодування та валідацію структури ML-KEM.

**Перевірка цілісності конверта.** Після розшифрування конверта функція `open` виконує додаткову перевірку консистентності: обчислює $pk_C' = sk_C \cdot g$ із відновленого приватного ключа $sk_C$ та порівнює результат із відновленим $pk_C$ через рівночасову функцію порівняння. Це виявляє пошкодження конверта, яке теоретично могло б обійти перевірку Poly1305 MAC (з нехтовно малою ймовірністю $\leq 2^{-128}$), забезпечуючи ешелонований захист.

**Перевірка довжин протокольних повідомлень.** Кожна функція синтаксичного аналізу (`parse_ke1`, `parse_ke2`, `parse_ke3`) відхиляє повідомлення, довжина яких не відповідає точному значенню константи (`KE1_LENGTH = 1272`, `KE2_LENGTH = 1376`, `KE3_LENGTH = 64`). Використання констант часу компіляції з твердженнями (`assert`) забезпечує статичну верифікацію коректності розмірів.

**Таблиця 6.9 --- Зведення перевірок вхідної валідації**

| Об'єкт валідації | Кількість перевірок | Тип помилки |
|---|---|---|
| Точки Ristretto255 (32 б) | 3 (довжина, тотожність, канонічність) | `InvalidPublicKey` |
| Скаляри Ristretto255 | 1 (ненульовість) | Повторна генерація |
| Буфери ML-KEM-768 | 3 ($|pk|$, $|ct|$, $|ss|$) | `InvalidKemInput` |
| Протокольні повідомлення | 3 ($|$KE1$|$, $|$KE2$|$, $|$KE3$|$) | `InvalidProtocolMessage` |
| Конверт | 2 (Poly1305 MAC, $pk_C$ консистентність) | `InvalidEnvelope` |
| FFI-покажчики | $N$ (кожна точка входу) | `InvalidInput` |

Загалом реалізація виконує щонайменше 12 незалежних перевірок для кожної операції автентифікації, формуючи ешелоновану систему захисту від некоректних криптографічних значень.

---

## 7. ОБГОВОРЕННЯ

### 7.1 Відповідність вимогам

**Таблиця 7.1 --- Відповідність протоколу встановленим вимогам**

| Вимога | Опис | Статус | Обґрунтування |
|---|---|---|---|
| R1 | Збереження властивостей OPAQUE | ✓ | aPAKE, OPRF, Argon2id, envelope залишаються незмінними; 126/126 тестів |
| R2 | Постквантова стійкість | ✓ | ML-KEM-768 IND-CCA2 (FIPS 203); лема `and_model` Tamarin доведена |
| R3 | AND-модель | ✓ | HKDF($dh_{1..4} \| ss_{\text{kem}}$); Теорема 4 + Tamarin P6 (29 кроків) |
| R4 | Мінімальні накладні витрати | ✓ | **+159,3 мкс** CPU на AKE (без KSF, Таблиця 6.6); +2272 байт (+516%); 0 додаткових раундів; 0,031% від наскрізного часу |
| R5 | Реалізованість | ✓ | 3749 рядків виробничого коду Rust, 4 крейти, 126 тестів, еталонні вимірювання Criterion |

**Коментар до вимоги R4.** Збільшення обсягу повідомлень (+2272 байти, +516%) є значним у відносних величинах, однак абсолютний обсяг (2712 байт) залишається в межах типового MTU Ethernet (1500 байт для кожного повідомлення). Повідомлення KE1 (1272 байти) та KE3 (64 байти) вміщуються в один UDP-датаграм; KE2 (1376 байт) також вміщується в один датаграм при IPv4 (MTU = 1500 байт) та потребує фрагментації лише при IPv6 із мінімальним MTU (1280 байт). Кількість раундів обміну (1,5 RTT) залишається незмінною порівняно з класичним OPAQUE, що є ключовим результатом: постквантовий захист досягнуто *без* додаткових мережевих обмінів.

### 7.2 Значення результатів формальної верифікації

Повна формальна верифікація (8/8 лем Tamarin + 5/5 запитів ProVerif) є ключовим результатом, що підносить цю роботу з рівня прикладної інженерної розробки до рівня наукового внеску в галузі безпеки протоколів.

**Обґрунтування використання двох незалежних інструментів.** ProVerif та Tamarin мають взаємодоповнюючі переваги: ProVerif краще масштабується для протоколів з необмеженим числом сесій (необмежена верифікація); Tamarin потужніший для складних властивостей зі станом (пряма секретність, AND-модель, ін'єктивна автентифікація). Спільна верифікація обома інструментами усуває хибні підтвердження, що можуть виникати через специфічні абстракції кожного інструмента окремо.

**Лема P6 (AND-модель) як центральний результат.** Ця лема формально доводить, що Hybrid PQ-OPAQUE забезпечує безпеку навіть при *повній* компрометації довготривалих ключів --- якщо ефемерні ключі збережені. Це суттєво сильніший результат, ніж типова TLS-верифікація, яка зазвичай захищає від пасивного підслуховування.

**Узгодженість трьох рівнів верифікації.** Зв'язок між символьним (Tamarin/ProVerif), редукційним (Теореми 1--5) та обчислювальним (Rust-тести) рівнями аналізу формує ієрархію довіри: кожен рівень підтверджує результати іншого, а вразливість, виявлена на будь-якому рівні, буде зафіксована на решті.

**Порівняння з верифікацією інших протоколів.** Глибина формальної верифікації Гібридного PQ-OPAQUE перевищує більшість існуючих постквантових гібридних протоколів:
- *TLS 1.3*: верифіковано ProVerif та Tamarin [46], однак постквантове розширення TLS 1.3 Hybrid [18] *не має* опублікованої формальної верифікації AND-моделі у символьній моделі;
- *Signal PQXDH* [19]: має доведення в обчислювальній моделі, але *не має* символьної верифікації Tamarin/ProVerif;
- *WireGuard PQ* [20]: верифіковано Tamarin для оригінального Noise IK, але PQ-розширення *не має* окремої верифікації;
- *Гібридний PQ-OPAQUE*: верифіковано обома інструментами (5/5 + 8/8), включаючи AND-модель (P6) та стійкість до словникового перебирання (P7) --- властивості, специфічні для aPAKE та відсутні в інших гібридних протоколах.

### 7.3 Аналіз продуктивності в контексті практичного застосування

Домінування Argon2id (510 мс = 99,8% наскрізного часу виконання) є не вадою, а **свідомим архітектурним рішенням**: саме висока обчислювальна вартість Argon2id гарантує практичну непридатність офлайн-атак перебирання за словником. Постквантові операції (122 мкс для ML-KEM-768, $\approx$164 мкс для 4DH) є статистично нехтовним доповненням.

Типовий сценарій застосування: час автентифікації для користувача --- 500 мс (домінує Argon2id на стороні ініціатора), затримка відповіді сервера --- менше 1 мс. Це відповідає загальноприйнятому порогу зручності використання (< 1 с для інтерактивних операцій) при дотриманні параметрів MODERATE, рекомендованих для серверної автентифікації [35].

Пропускна здатність вузла-респондера (1,31 млн автентифікацій на секунду на одному ядрі) підтверджує, що сервер не є вузьким місцем навіть при великому масштабі. Горизонтальне масштабування вузлів-респондерів лінійно збільшує сукупну пропускну здатність системи.

**Порівняння з типовими вимогами.** Для типових веб-застосунків (10\,000--100\,000 одночасних користувачів) потрібна пропускна здатність $\approx 1{,}000$--$10{,}000$ автентифікацій на секунду. Один вузол-респондер забезпечує $1{,}31 \times 10^6$ авт./с, що перевищує цю вимогу на три порядки. Навіть при врахуванні мережевих затримок та операцій введення-виведення бази даних (типово $\approx 1$--5 мс на запит), один 8-ядерний сервер здатний обслуговувати $\approx 2{,}000$--$8{,}000$ автентифікацій на секунду --- достатньо для більшості виробничих сценаріїв.

**Вплив на мобільні платформи.** На мобільних пристроях (ARM Cortex-A78, $\approx 2{,}5$ ГГц) час виконання Argon2id з параметрами MODERATE може перевищувати 1 секунду через менший обсяг пропускної здатності пам'яті та нижчу тактову частоту. У таких сценаріях рекомендується використання параметрів INTERACTIVE (1 ітерація, 64 МБ), що зменшує час до $\approx 200$ мс при прийнятному зниженні стійкості до офлайн-перебирання (Підрозділ 7.5).

### 7.4 Стратегія міграції та зворотна сумісність

Практичне впровадження Гібридного PQ-OPAQUE в існуючу інфраструктуру, що використовує класичний OPAQUE, потребує розгляду стратегії міграції та питань зворотної сумісності.

**Трифазна міграція.** Рекомендована процедура переходу складається з трьох послідовних фаз: (1) *оновлення серверної частини* --- вузол-респондер розширюється підтримкою ML-KEM-768, формат реєстраційного запису залишається незмінним (168 байт); (2) *повторна реєстрація клієнтів* --- ініціатори виконують повторну реєстрацію з PQ-спроможним клієнтом, генеруючи нові конверти, що включають параметри KEM; (3) *припинення підтримки класичного режиму* --- після завершення перехідного періоду класичні повідомлення KE1 (88 байт) відхиляються як некоректні.

**Версіонування через доменні мітки.** Протокол використовує версіоновані мітки (`ECLIPTIX-OPAQUE-v1/` та `ECLIPTIX-OPAQUE-PQ-v1/`). Майбутні версії (наприклад, з ML-KEM-1024 або іншим KEM) можуть використовувати мітку `ECLIPTIX-OPAQUE-PQ-v2/`. Транскриптне зв'язування (Підрозділ 4.4) гарантує, що обидві сторони повинні узгодити версію: будь-яка невідповідність міток призведе до незбіжності гешів транскрипту та відхилення MAC.

**Навмисна зворотна несумісність.** Гібридний протокол *не є* зворотно сумісним із класичним OPAQUE на рівні дротового формату: KE1 складає 1272 байти проти 88 байт класичного. Класичний сервер відхилить гібридний KE1 як повідомлення некоректного формату. Ця несумісність є *навмисною*: вона запобігає атакам зниження рівня безпеки (downgrade), при яких противник міг би перевести протокол у класичний режим без відома обох сторін.

**Вплив на базу даних.** Реєстраційний запис залишається незмінним (168 байт: конверт 136 б + відкритий ключ клієнта 32 б). Постквантові компоненти ($pk_{\text{kem}}$, $sk_{\text{kem}}$, $ct_{\text{kem}}$) є ефемерними та генеруються для кожної сесії автентифікації. Тому схема бази даних *не потребує змін* при міграції. Єдиною вимогою є захист глобального насіння `oprf_seed` з тим самим рівнем безпеки, що й раніше.

### 7.5 Аналіз параметрів Argon2id та компроміс безпека--зручність використання

Параметри функції жорсткого перетворення пароля Argon2id суттєво впливають на два конкуруючих аспекти: захист від офлайн-перебирання та зручність використання (час відгуку).

**Параметри MODERATE.** Реалізація використовує параметри `OPSLIMIT_MODERATE` (3 ітерації) та `MEMLIMIT_MODERATE` (256 МБ) бібліотеки libsodium, що забезпечують час виконання $\hat{\mu} = 510{,}86$ мс на Apple M1 Pro. Ці параметри призначені для серверної автентифікації, де затримка 500 мс є прийнятною.

**Модель вартості офлайн-перебирання.** З параметрами MODERATE кожна спроба вгадування пароля коштує $\approx 500$ мс. Для словника обсягом $|\mathcal{D}| = 10^6$ (типовий розмір при цільових атаках) повний перебір вимагає $\approx 5{,}8$ діб на одному ядрі. При паралелізації з використанням ASIC/GPU (оцінка прискорення $\times 100$) час зменшується до $\approx 1{,}4$ години. Проте вимога використання 256 МБ пам'яті на кожну спробу робить GPU-атаки значно дорожчими, ніж для PBKDF2 або bcrypt, оскільки кількість паралельних екземплярів обмежена обсягом пам'яті GPU (наприклад, GPU з 16 ГБ може виконувати не більше 64 паралельних обчислень Argon2id-MODERATE).

**Альтернативні параметри.** Для інтерактивних мобільних додатків параметри `OPSLIMIT_INTERACTIVE` (1 ітерація, 64 МБ, $\approx 100$ мс) можуть бути доцільнішими. При цих параметрах PQ-накладні витрати (159 мкс) складатимуть 0,16% від часу Argon2id --- все ще нехтовно мала величина. Для середовищ Інтернету речей з обмеженими ресурсами рекомендується поєднання INTERACTIVE-параметрів із серверним обмеженням частоти запитів (rate limiting) для компенсації зниженої стійкості до офлайн-перебирання.

**Взаємодія з PQ-накладними витратами.** Незалежно від обраних параметрів Argon2id, постквантові накладні витрати ($\Delta_{PQ} = 159{,}3$ мкс) залишаються на 3--4 порядки нижчими за час виконання функції жорсткого перетворення. Це підтверджує фундаментальний висновок: вибір параметрів Argon2id, а не інтеграція ML-KEM-768, є визначальним чинником латентності, що сприймається користувачем.

### 7.6 Поточні обмеження

**Відповідність стандарту IETF.** Реалізація є «OPAQUE-подібною» та не є повністю конформною до специфікації `draft-irtf-cfrg-opaque` [6]. Формат серіалізації повідомлень відрізняється від специфікації IETF. Це свідоме архітектурне рішення, прийняте з метою спрощення інтеграції постквантового компонента та чіткості дослідної реалізації.

**Рівень зрілості PQ-стандартів.** ML-KEM-768 (FIPS 203) --- відносно новий стандарт (серпень 2024). Хоча до нього не відомі практичні атаки, ступінь криптоаналізу значно менший, ніж для Curve25519 (10+ років). AND-модель захищає від цього ризику: навіть при виявленні вразливості в ML-KEM безпека зберігається на рівні класичного OPAQUE.

**Абстракція в символьній верифікації.** Tamarin/ProVerif верифікують символьну модель, а не Rust-реалізацію. Розрив між символьним та обчислювальним рівнями є стандартним обмеженням формальної верифікації [42]. Computational soundness результатів базується на тому, що конкретні примітиви (libsodium, ml-kem) відповідають своїм абстрактним специфікаціям.

**Збільшення обсягу повідомлень.** Інтеграція ML-KEM-768 збільшує сумарний обсяг повідомлень автентифікації на +2272 байти (+516%): KE1 зростає з 88 до 1272 байт ($+pk_{\text{kem}}$ = 1184 б), KE2 --- з 288 до 1376 байт ($+ct_{\text{kem}}$ = 1088 б). У мережевих середовищах із суттєвими обмеженнями максимального розміру блоку передавання (MTU) повідомлення KE1 та KE2 потребуватимуть фрагментації на рівні транспортного протоколу. Для UDP-транспорту (MTU = 1280 байт в IPv6) KE2 потребуватиме щонайменше двох фрагментів, що збільшує латентність на одну RTT у найгіршому випадку.

**Обмежена кількість платформ тестування.** Всі вимірювання продуктивності виконано на одній апаратній платформі (Apple M1 Pro, macOS). Хоча криптографічні операції Ristretto255 та ML-KEM-768 є платформо-незалежними на рівні алгоритмів, абсолютні значення часу виконання можуть суттєво відрізнятися на платформах x86-64 (Intel/AMD), ARM без криптографічних розширень та вбудованих системах. Зокрема, ML-KEM-768 використовує числове теоретичне перетворення (NTT), продуктивність якого залежить від наявності SIMD-інструкцій.

### 7.7 Напрямки подальших досліджень

1. **Конформність до стандарту IETF.** Адаптація серіалізації повідомлень до специфікації `draft-irtf-cfrg-opaque` [6] для досягнення взаємосумісності з існуючими реалізаціями OPAQUE. Ключовими відмінностями є формат серіалізації (бінарний TLV у специфікації IETF проти фіксованих зміщень у цій реалізації) та нумерація полів повідомлень.
2. **Постквантові цифрові підписи.** Дослідження заміни кодів автентифікації повідомлень HMAC-SHA-512 на схему ML-DSA (FIPS 204) [16] для забезпечення властивості невідмовності (non-repudiation). ML-DSA-65 (рівень 3) додасть $\approx 3{,}3$ КБ до обсягу повідомлень ($|sig| = 3309$ байт), що суттєво збільшить розмір KE2 та KE3, однак забезпечить юридично значущу невідмовність.
3. **ML-KEM-512 для пристроїв з обмеженими ресурсами.** Оцінка компромісу між рівнем безпеки (NIST Рівень 1, еквівалент AES-128) та обсягом накладних витрат (зменшення розміру відкритого ключа на $\approx 32\%$: 800 б проти 1184 б) у сценаріях Інтернету речей. Таблиця 2.2 надає порівняння параметрів усіх рівнів ML-KEM.
4. **Доведення в моделі Universal Composability.** Формальне доведення Гібридного PQ-OPAQUE в рамках UC-моделі [22] для постквантових розширень. UC-доведення гарантує безпеку при довільній композиції протоколу з іншими протоколами --- суттєво сильніша гарантія, ніж символьна верифікація. Основною технічною складністю є побудова симулятора для гібридного комбінатора.
5. **Подання до IETF CFRG.** Розробка та подання пропозиції щодо стандартизованого постквантового розширення протоколу OPAQUE, побудованого на результатах цієї роботи. IETF CFRG активно розглядає стандартизацію гібридних PAKE як пріоритетне завдання.
6. **Постквантова OPRF.** Дослідження решітково-орієнтованих замінників Ristretto255-OPRF (на основі Module-LWE) для досягнення повної постквантової стійкості *без* гібридного підходу. Поточна конструкція залишає OPRF-компонент класичним, що обмежує стійкість до квантових атак на рівні OPRF.
7. **Формальна верифікація Rust-реалізації.** Застосування інструментів верифікації Rust-коду (Kani, Creusot) для формального доведення коректності *реалізації*, а не лише абстрактної моделі. Це зменшить залишковий розрив між символьною та обчислювальною моделями (Підрозділ 5.4).

---

## 8. ВИСНОВКИ

У даній роботі вирішено актуальну наукову задачу: розроблено, формально верифіковано та реалізовано гібридний постквантовий протокол PAKE, що забезпечує одночасний захист від класичних та квантових криптоаналітичних атак.

**Теоретичний внесок.** Запропоновано конструкцію Гібридного PQ-OPAQUE, де механізм інкапсуляції ключів ML-KEM-768 (FIPS 203) є *обов'язковою* складовою протоколу 4DH OPAQUE, а не факультативним розширенням. Гібридний комбінатор
$$\text{PRK} = \text{HKDF-Extract}(\text{salt}_{\tau},\; dh_1 \| dh_2 \| dh_3 \| dh_4 \| ss_{\text{kem}})$$
з розширеним транскриптом (що включає $pk_{\text{kem}}$ та $ct_{\text{kem}}$) реалізує AND-модель безпеки (Теорема 4). Четвертий добуток Діффі--Геллмана ($dh_4 = e_S \cdot E_C$) забезпечує стійкість до атаки підміни ключа (UKS). Показано, що всі фундаментальні властивості OPAQUE зберігаються: таємність пароля (Теорема 1), пряма секретність (Теорема 2), взаємна автентифікація (Теорема 3).

**Верифікаційний внесок.** Вперше для гібридного постквантового розширення OPAQUE отримано повну формальну верифікацію двома незалежними інструментами:
- **ProVerif 2.05**: 5/5 запитів підтверджено (секретність ключа, секретність пароля, автентифікація ініціатора/респондера, ін'єктивна взаємна автентифікація);
- **Tamarin Prover 1.10.0**: 8/8 лем доведено за 28,08 с; зокрема пряма секретність (119 кроків) та AND-модель гібридної безпеки (29 кроків).

**Реалізаційний та вимірювальний внесок.** Реалізація мовою Rust (4 крейти, 3749 рядків виробничого коду, 2731 рядків тестів):
- **126 тестових сценаріїв: 0 відмов** (7 інтеграційних, 34 властивості безпеки, 5 на основі властивостей, 80 модульних);
- $\texttt{authentication\_e2e}$ = **481,43 мс** (Apple M1 Pro, 95% ДІ [471,73; 495,25]); Argon2id = 510,86 мс (99,8\% часу виконання); повний раунд ML-KEM-768 = 122,01 мкс;
- Пропускна здатність респондера (без Argon2id) = **1,31 млн авт./с**;
- Постквантові накладні витрати (порівняльний модуль, Таблиця 6.6): **+159,3 мкс** на повний ключовий обмін без KSF (+30,1%); відносно наскрізного часу = **0,031%**; збільшення обсягу повідомлень = +2272 байт (+516%) при незмінних 1,5 обміни.

**Верифікаційна глибина.** П'ять формальних моделей загальним обсягом 1806 рядків коду охоплюють протокол з різних ракурсів: модель секретності ProVerif (необмежена кількість сесій), модель автентифікації ProVerif (ін'єктивна відповідність), повна модель Tamarin (вбудована теорія DH, стала орієнтиром для верифікованої версії), верифікована модель Tamarin (абстрактний DH, 8/8 лем за 28,08 с), та ASCII-сумісна версія для зовнішнього огляду. Проблема вибуху простору станів при використанні вбудованої теорії DH у Tamarin вирішена через звукову абстракцію --- підхід, обґрунтований стандартною методологією символьної верифікації [42, 46].

**Внесок UKS-стійкості.** Четвертий добуток Діффі--Геллмана $dh_4 = e_S \cdot E_C$, відсутній у специфікації IETF [6], забезпечує стійкість до атаки підміни ключа (Теорема 5). Ця модифікація посилює безпеку протоколу ціною одного додаткового скалярного множення ($\approx 41$ мкс).

**Готовність до впровадження.** Реєстраційний запис (168 байт) та схема бази даних залишаються незмінними при міграції від класичного OPAQUE. Постквантові компоненти є ефемерними та не потребують персистентного зберігання. Трифазна стратегія міграції (Підрозділ 7.4) забезпечує поступовий перехід без переривання роботи системи.

Практичне значення результатів полягає в тому, що розроблений протокол надає системам парольної автентифікації можливість перейти до постквантового захисту вже сьогодні, без збільшення кількості раундів обміну та з нехтовно малими накладними витратами CPU. Гібридний підхід за AND-моделлю безпеки гарантує збереження класичного рівня захисту навіть у разі виявлення майбутніх вразливостей у ML-KEM-768, що є критично важливим в умовах перехідного періоду постквантової міграції.

---

## СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

[1] Bonneau J., Herley C., van Oorschot P. C., Stajano F. The quest to replace passwords: A framework for comparative evaluation of web authentication schemes // Proc. IEEE Symposium on Security and Privacy (S&P). --- 2012. --- P. 553--567.

[2] Florencio D., Herley C. A large-scale study of web password habits // Proc. 16th International Conference on World Wide Web (WWW). --- 2007. --- P. 657--666.

[3] Bellare M., Pointcheval D., Rogaway P. Authenticated key exchange secure against dictionary attacks // EUROCRYPT 2000, LNCS 1807. --- Springer, 2000. --- P. 139--155.

[4] Jarecki S., Krawczyk H., Xu J. OPAQUE: An asymmetric PAKE protocol secure against pre-computation attacks // EUROCRYPT 2018, LNCS 10822. --- Springer, 2018. --- P. 456--486.

[5] Freedman M. J., Ishai Y., Pinkas B., Reingold O. Keyword search and oblivious pseudorandom functions // TCC 2005, LNCS 3378. --- Springer, 2005. --- P. 303--324.

[6] Bourdrez D., Krawczyk H., Lewi K., Wood C. A. The OPAQUE asymmetric PAKE protocol // IETF Internet-Draft draft-irtf-cfrg-opaque. --- 2024.

[7] Wu T. The Secure Remote Password protocol // NDSS 1998. --- P. 97--111.

[8] Abdalla M., Pointcheval D. Simple password-based encrypted key exchange protocols // CT-RSA 2005, LNCS 3376. --- Springer, 2005. --- P. 191--208.

[9] Shor P. W. Algorithms for quantum computation: Discrete logarithms and factoring // FOCS 1994. --- P. 124--134.

[10] Bernstein D. J., Lange T. Post-quantum cryptography // Nature. --- 2017. --- Vol. 549, No. 7671. --- P. 188--194.

[11] Roetteler M., Naehrig M., Svore K. M., Lauter K. Quantum resource estimates for computing elliptic curve discrete logarithms // ASIACRYPT 2017, LNCS 10625. --- Springer, 2017. --- P. 241--270.

[12] National Academies of Sciences, Engineering, and Medicine. Quantum computing: Progress and prospects. --- Washington, DC: National Academies Press, 2019.

[13] Mosca M. Cybersecurity in an era with quantum computers: Will we be ready? // IEEE Security & Privacy. --- 2018. --- Vol. 16, No. 5. --- P. 38--41.

[14] National Institute of Standards and Technology. Post-quantum cryptography: Call for proposals // Federal Register. --- 2016.

[15] National Institute of Standards and Technology. Module-Lattice-Based Key-Encapsulation Mechanism Standard: FIPS 203. --- 2024.

[16] National Institute of Standards and Technology. Module-Lattice-Based Digital Signature Standard: FIPS 204. --- 2024.

[17] Avanzi R., Bos J., Ducas L., et al. CRYSTALS-Kyber: Algorithm specifications and supporting documentation (version 3.02) // NIST PQC Standardization, Round 3. --- 2022.

[18] Stebila D., Fluhrer S., Gueron S. Hybrid key exchange in TLS 1.3 // IETF Internet-Draft draft-ietf-tls-hybrid-design. --- 2024.

[19] Brendel J., Fiedler R., Günther F., Jacobsen C., Poettering B. Post-quantum security of the Signal protocol // SAC 2020, LNCS 12804. --- Springer, 2020. --- P. 567--591.

[20] Hülsing A., Ning K.-C., Schwabe P., Weber F., Zimmermann P. R. Post-quantum WireGuard // IEEE S&P 2021. --- P. 304--321.

[21] Bindel N., Hamburg M., Hövelmanns K., Hülsing A., Persichetti E. Tighter proofs of CCA security in the quantum random oracle model // PQCrypto 2019, LNCS 11505. --- Springer, 2019. --- P. 61--79.

[22] Canetti R. Universally composable security: A new paradigm for cryptographic protocols // FOCS 2001. --- P. 136--145.

[23] Ding J., Alsayigh S., Saraswathy R. V., Fluhrer S., Lin X. Leakage of signal function with reused keys in RLWE key exchange // CT-RSA 2017, LNCS 10159. --- Springer, 2017. --- P. 297--314.

[24] Boyko V., MacKenzie P., Patel S. Provably secure password-authenticated key exchange using Diffie-Hellman // EUROCRYPT 2000, LNCS 1807. --- Springer, 2000. --- P. 156--171.

[25] Bellovin S. M., Merritt M. Encrypted key exchange: Password-based protocols secure against dictionary attacks // IEEE S&P 1992. --- P. 72--84.

[26] Haase B., Labrique B. AuCPace: Efficient verifier-based PAKE protocol tailored for the IIoT // IACR TCHES. --- 2019. --- Vol. 2019, No. 2. --- P. 1--48.

[27] Ladd W., Kaduk B., Harkins D. SPAKE2, a PAKE // IETF RFC 9382. --- 2023.

[28] Abdalla M., Eisenberg J., Haase B., Hauck E., Kiltz E., Loss J. The OPAQUE PAKE: A rigorous PAKE framework and Instant OPAQUE // CRYPTO 2021, LNCS 12828. --- Springer, 2021. --- P. 278--308.

[29] Wu T. SRP: Secure Remote Password // RFC 2945. --- 1998.

[30] de Valence H., Grigg J., Hamburg M., Lovecruft I., Tankersley G., Valsorda F. The ristretto255 and decaf448 groups // IETF Internet-Draft draft-irtf-cfrg-ristretto255-decaf448. --- 2024.

[31] Biryukov A., Dinu D., Khovratovich D. Argon2: New generation of memory-hard functions for password hashing and other applications // IEEE Euro S&P 2016. --- P. 292--302.

[32] Nir Y., Langley A. ChaCha20 and Poly1305 for IETF Protocols // IETF RFC 8439. --- 2018.

[33] Krawczyk H., Eronen P. HMAC-based Extract-and-Expand Key Derivation Function (HKDF) // IETF RFC 5869. --- 2010.

[34] Regev O. On lattices, learning with errors, random linear codes, and cryptography // Journal of the ACM. --- 2009. --- Vol. 56, No. 6. --- Article 34.

[35] Denis F. libsodium: A modern, portable, easy to use crypto library. --- URL: https://doc.libsodium.org/; Open Quantum Safe Project. liboqs. --- URL: https://openquantumsafe.org/.

[36] Matsakis N. D., Klock II F. S. The Rust language // ACM SIGADA Ada Letters. --- 2014. --- Vol. 34, No. 3. --- P. 103--104.

[37] Heyer C. et al. Criterion.rs: Statistics-driven micro-benchmarking in Rust. --- URL: https://github.com/bheisler/criterion.rs. --- 2023.

[38] Blanchet B. An efficient cryptographic protocol verifier based on Prolog rules // Proc. 14th IEEE Computer Security Foundations Workshop. --- IEEE, 2001. --- P. 82--96.

[39] Meier S., Schmidt B., Cremers C., Basin D. The TAMARIN prover for the symbolic analysis of security protocols // CAV 2013, LNCS 8044. --- Springer, 2013. --- P. 696--701.

[40] Beguinet H., Chevalier C., Pointcheval D., Ricosset T., Rossi M. Get Me out of This Lattice: CRYSTALS-Kyber and Post-Quantum Signal // ACM CCS 2023, Proceedings. --- 2023.

[41] Castryck W., Decru T. An efficient key recovery attack on SIDH // EUROCRYPT 2023, LNCS 14008. --- Springer, 2023. --- P. 423--447.

[42] Cremers C., Mauw S. Operational Semantics and Verification of Security Protocols. --- Springer, 2012.

[43] Basin D., Cremers C., Meadows C. Model checking security protocols // Handbook of Model Checking. --- Springer, 2018. --- P. 727--762.

[44] Giacon F., Kiltz E., Moed S. KEM Combiners // PKC 2018, LNCS 10769. --- Springer, 2018. --- P. 190--218.

[45] Dowling B., Fischlin M., Günther F., Stebila D. A cryptographic analysis of the TLS 1.3 handshake protocol // Journal of Cryptology. --- 2021. --- Vol. 34, No. 4. --- Article 37.

[46] Cremers C., Horvat M., Hoyland J., Scott S., van der Merwe T. A comprehensive symbolic analysis of TLS 1.3 // Proc. ACM SIGSAC Conference on Computer and Communications Security (CCS). --- 2017. --- P. 1773--1788.
