### 5.4 Формальна верифікація у системі ProVerif

#### 5.4.1 Методологія та модель загроз

На доповнення до теоретичного аналізу безпеки (підрозд. 5.1–5.3), проведено формальну верифікацію протоколу Hybrid PQ-OPAQUE у системі автоматичного доведення ProVerif 2.05 [22]. ProVerif реалізує символьну модель Dolev–Yao [23], в якій криптографічні примітиви вважаються ідеальними (perfect cryptography assumption): функції шифрування, MAC та деривації ключів трактуються як довільні функції без алгебраїчних вразливостей; єдині знання противника — ті, що він явно отримує по відкритому каналу.

**Модель противника.** Противник $\mathcal{A}$ у символьній моделі:
- контролює весь мережевий трафік (перехоплення, підміна, повторна передача);
- може ініціювати довільну кількість паралельних та послідовних сесій;
- має доступ до серверної бази даних (OPRF-ключ та зашифрований конверт);
- може компрометувати довготривалі ключі сервера ($S_s$).

**Обмеження символьної моделі.** Символьна верифікація не охоплює атаки через бічні канали, статистичну нерозрізнимість ключового матеріалу (computational indistinguishability) або конкретні параметри безпеки. Ці аспекти адресуються теоремами 1–4 (підрозд. 5.1) та результатами емпіричного тестування (розд. 6).

#### 5.4.2 Моделювання протоколу

Верифікація реалізована за допомогою двох ProVerif-моделей, що розмежовують властивості секретності та автентифікації.

**Модель секретності** (`hybrid_pq_opaque.pv`). Охоплює повний цикл протоколу: реєстрацію через безпечний канал `secure_reg` та необмежену кількість автентифікаційних сесій на відкритому каналі `c`. Критичне моделювання — явна компрометація довготривалого ключа сервера:

```proverif
( !ClientAuth(secret_pwd, pkS)
| !ServerAuth(skS, pkS, record_stored2, oprf_key_stored)
| (event ServerLTKCompromised(pkS); out(c, skS))
)
```

Включення події `ServerLTKCompromised` дозволяє верифікувати найсильніші форми секретності: властивість залишається верифікованою навіть коли $S_s$ відомий противнику.

**Модель автентифікації** (`hybrid_pq_opaque_auth.pv`). Для верифікації властивостей correspondence (автентифікаційних запитів) використано спрощену модель з абстрагованим OPRF та явними конструкторами для транскрипту:

```proverif
fun make_transcript(point, point, nonce, nonce, point, point, kem_pk, kem_ct): bitstring.
fun hkdf_extract4(key, key, key, key): key.
```

Ця абстракція зберігає ключовий інваріант протоколу — **прив'язку транскрипту** (transcript binding): session key пов'язаний із конкретними значеннями всіх публічних елементів обміну, включаючи постквантовий відкритий ключ та шифротекст. Використання двох моделей є стандартною практикою при верифікації складних протоколів [24, 25].

#### 5.4.3 Результати верифікації

Верифікація виконана на платформі macOS Darwin 25.2.0 (Apple M1 Pro). ProVerif 2.05 встановлено через систему OPAM (OCaml 5.4.0).

**Запит PV-1: Секретність сесійного ключа.**

```proverif
free sess_key_test: key [private].
query attacker(sess_key_test).
```

ProVerif будує дерево дедукції для всіх можливих стратегій противника та перевіряє, чи може `sess_key_test` стати досяжним (reachable) фактом. Результат верифікації:

```
RESULT not attacker(sess_key_test[]) is true.
```

Цей результат підтверджує, що в символьній моделі Dolev–Yao жодна стратегія противника не дозволяє вивести сесійний ключ із публічно спостережуваного трафіку та серверної бази даних (включаючи $S_s$). Формально: $\forall \mathcal{A}$ (Dolev–Yao): $\text{sess\_key\_test} \notin \text{Derivable}(\mathcal{A}, \text{Transcript})$.

**Запит PV-2: Секретність паролю.**

```proverif
free secret_pwd: password [private].
query attacker(secret_pwd).
```

Результат:

```
RESULT not attacker(secret_pwd[]) is true.
```

Верифікація підтверджує, що символьний противник не може вивести пароль навіть при компрометації серверного ключа. Це є формальним підтвердженням властивості offline dictionary attack resistance: пароль ніколи не передається у відкритому вигляді, а зашифрований конверт $\text{Envelope} = \text{AEnc}(K_{\text{env}}, \text{nonce}, (S_s, C_s, \text{pk}_C))$ захищений ключем, що виводиться з виходу OPRF та Argon2id — без знання паролю цей ключ нерозрізнимий від випадкового.

**Запит PV-3: Відповідність клієнт→сервер.**

```proverif
query pkC: point, pkS: point, sk: key;
  event(ClientCompletesAuth(pkC, pkS, sk))
  ==> event(ServerAcceptsAuth(pkS, pkC, sk)).
```

Результат:

```
RESULT event(ClientCompletesAuth(pkC_2,pkS_1,sk)) ==>
       event(ServerAcceptsAuth(pkS_1,pkC_2,sk)) is true.
```

Ця властивість correspondence гарантує, що кожен факт успішного завершення автентифікації на стороні клієнта (верифікація server MAC, відправка KE3) обов'язково передує участі легітимного сервера, який прийняв ту саму сесію із тим самим ключем. Верифікація виключає сценарій, в якому клієнт вважає автентифікацію успішною без реальної участі сервера.

**Запит PV-4: Відповідність сервер→клієнт.**

```proverif
query pkC: point, pkS: point, sk: key;
  event(ServerCompletesAuth(pkS, pkC, sk))
  ==> event(ClientStartsAuth(pkC, pkS)).
```

Результат:

```
RESULT event(ServerCompletesAuth(pkS_1,pkC_2,sk)) ==>
       event(ClientStartsAuth(pkC_2,pkS_1)) is true.
```

Верифікація підтверджує, що сервер не може завершити автентифікацію (верифікувати client MAC у KE3) без попереднього ініціювання сесії легітимним клієнтом. Це виключає атаки імперсонації клієнта з боку активного мережевого противника.

**Запит PV-5: Ін'єктивна взаємна автентифікація (стійкість до атак повторного відтворення).**

```proverif
query pkC: point, pkS: point, sk: key;
  inj-event(ServerCompletesAuth(pkS, pkC, sk))
  ==> inj-event(ClientCompletesAuth(pkC, pkS, sk)).
```

Результат:

```
RESULT inj-event(ServerCompletesAuth(pkS_1,pkC_2,sk)) ==>
       inj-event(ClientCompletesAuth(pkC_2,pkS_1,sk)) is true.
```

Ін'єктивна (injective) властивість відповідності є суворішою за просту correspondence: вона встановлює **ін'єктивне відображення** між подіями завершення сесії сервером та подіями завершення сесії клієнтом. Формально: якщо сервер завершив дві різні сесії, то для них існують два різних, унікальних завершення на стороні клієнта. Це безпосередньо виключає **атаки повторного відтворення (replay attacks)**: противник не може змусити сервер завершити нову сесію, повторно надіславши перехоплений KE3 від попередньої сесії, оскільки кожна сесія містить унікальні ефемерні ключі та нонси, пов'язані транскриптом.

#### 5.4.4 Зведена таблиця результатів верифікації

| № | Властивість безпеки | Модель ProVerif | Результат |
|---|---------------------|-----------------|-----------|
| PV-1 | Секретність сесійного ключа (incl. LTK compromise) | `hybrid_pq_opaque.pv` | ✓ `true` |
| PV-2 | Секретність паролю (incl. server DB compromise) | `hybrid_pq_opaque.pv` | ✓ `true` |
| PV-3 | Відповідність клієнт→сервер | `hybrid_pq_opaque_auth.pv` | ✓ `true` |
| PV-4 | Відповідність сервер→клієнт | `hybrid_pq_opaque_auth.pv` | ✓ `true` |
| PV-5 | Ін'єктивна взаємна автентифікація | `hybrid_pq_opaque_auth.pv` | ✓ `true` |

Усі п'ять запитів підтверджено. Жодних атак або контрприкладів у символьній моделі не виявлено.

#### 5.4.5 Зв'язок із теоретичними теоремами

Результати формальної верифікації у ProVerif корелюють із теоретичними теоремами підрозд. 5.1:

- **PV-1** є символьним аналогом **Теореми 2** (Пряма секретність): відсутність ефемерних ключів у знаннях противника після закінчення сесії унеможливлює відновлення сесійного ключа навіть при компрометації довготривалих ключів.

- **PV-2** є символьним аналогом **Теореми 1** (Секретність паролю): ланцюжок OPRF → Argon2id → XChaCha20-Poly1305 не розкриває пароль жодній стороні протоколу.

- **PV-3, PV-4** є символьним аналогом **Теореми 3** (Взаємна автентифікація): MAC на основі транскрипту зі спільним ключовим матеріалом забезпечує автентифікацію обох сторін.

- **PV-5** (ін'єктивна відповідність) є більш сильним твердженням, що не має прямого аналога в підрозд. 5.1, та підтверджує стійкість до атак повторного відтворення на символьному рівні.

Формальна верифікація у ProVerif не замінює, але доповнює і посилює теоретичний аналіз безпеки: вона виключає широкий клас логічних помилок у конструкції протоколу, що не завжди очевидні з редукційних доведень.

#### 5.4.6 Примітки щодо верифікації AND-моделі

Запит PV-1 верифікує секретність сесійного ключа при умові, що противник може отримати довготривалий ключ сервера $S_s$. Оскільки в символьній моделі всі криптографічні операції є ідеальними, пряма верифікація AND-моделі (теорема 4) виходить за межі Dolev–Yao символіки — вона потребує обчислювальної моделі (наприклад, CryptoVerif [26]). Тим не менш, структура моделі явно відображає AND-властивість: сесійний ключ виводиться з `hkdf_extract4(dh1, dh2, dh3, kem_ss)`, де `kem_ss` є незалежним від DH-компонентів символьним атомом. У символьній моделі це означає, що для отримання сесійного ключа противник має отримати **обидва** компоненти — класичний ($\text{dh}_1, \text{dh}_2, \text{dh}_3$) та постквантовий ($\text{kem\_ss}$) — що є недосяжним без контролю над відповідними секретними ключами. Результат PV-1 `is true` підтверджує цю структурну властивість.
